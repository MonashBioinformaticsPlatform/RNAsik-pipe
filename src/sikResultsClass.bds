
class AlignerResults {

    Sample[] results
    //TODO this a bug, this class takes sikBWAalignerConfig class, however it needs to be generic since STAR aligner will give a different class
    // rather a class should be AlignerConfig class, that returns appropriate config file
    void AlignerResults(SikConfig sikConf, AlignerConfig alignerConf, string genomeIdx, string[] idxDeps) {

        string metadataFn = sikConf.sikCmdFlags{"metadata"}
        string aligner = sikConf.sikCmdFlags{"aligner"}
        string sikDir = sikConf.sikCmdFlags{"outDir"}

        Samples samples = new Samples(metadataFn, sikDir, aligner)

        switch(aligner) {
            case 'star':
                for(Sample s : samples.samples) {
                    Sample result = mapSTAR(alignerConf.sikStarAlignerConf, s, genomeIdx, idxDeps)
                    this.results.add(result)
                }
                break
            case 'hisat2':
                error("SikErr: Haven't been implemented yet")
                break
            case 'bwaMem':
                for(Sample s : samples.samples) {
                    Sample result = mapBWA(alignerConf.sikBWAalignerConf, s, genomeIdx, idxDeps)
                    this.results.add(result)
                }
                break
            default:
                error("SikErr: There needs to be an error here to make sure nothing else is passed through, other than allowed aligners")
        }
    }
}

class BamResults {
   //TODO Return bam files, sorted and if flaged mdups. These are the bams that moving forward for counting and the rest of the analysis

    Sample[] results

    void BamResults(Sample[] alignerResults, SikConfig sikConf, SortConfig sortConf) {

        Sample[] tmpRes

        string sikDir = sikConf.sikCmdFlags{"outDir"}
        bool mdups = sikConf.sikCmdFlags{"mdups"}.parseBool()
        string sortingTool = "samtools" //TODO should really move this variable into sikConf

        switch(sortingTool) {
            case 'samtools':
                for(Sample s : alignerResults) {
                    Sample result = doBamSort(s, sortConf.samtoolsSortConf, sikDir)
                    tmpRes.add(result)
                }
                break
            case 'picard':
                error("SikErr: Haven't been implemented yet")
                break
            default:
                error("SikErr: There needs to be an error here to make sure nothing else is passed through, other than allowed aligners")
        }

        //NOTE this should allow me later to loop over tmpRes and pass it to mdups processing, tool agnostic
        // and in the second switch I'd do this.results.add(results)
        //This is kinder of ugly.. will think of a better solution
        if(!mdups && this.results.isEmpty()) {
           this.results = tmpRes
        }

        //TODO I guess will add a second switch statement later to do mdups, once again allowing for multiple tools selection
        string[] bamGoals

        for(Sample s : results) {
            bamGoals.add(s.bams.bamAlignerLog)
            bamGoals.add(s.bams.bamSortedLog)
            bamGoals.add(s.bams.bamSortedOut)
            bamGoals.add(s.bams.bamSortedIdx)
        }

        goal results
        //string mdupsTool = "samtools" or "picard"
    }
}

class ReadsCount {

    Sample[] counts

    void ReadsCount(Sample[] bamResults, string geneModels, string sikDir, SikCountsConfig sikCntsConf) {

        for(Sample s : bamResults) {
            Sample count = doReadsCount(s, sikCntsConf, geneModels, sikDir)
            counts.add(count)
        }

        string[] readCntsGoals

        for(Sample s : counts) {
            readCntsGoals.add(s.counts.cntsNon)
            readCntsGoals.add(s.counts.cntsNonLog)
            readCntsGoals.add(s.counts.cntsFwd)
            readCntsGoals.add(s.counts.cntsFwdLog)
            readCntsGoals.add(s.counts.cntsRev)
            readCntsGoals.add(s.counts.cntsRevLog)
        }

        goal readCntsGoals

    }
}
