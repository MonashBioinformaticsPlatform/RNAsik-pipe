
class AlignerResults {

    Sample[] results
    //TODO this a bug, this class takes sikBWAalignerConfig class, however it needs to be generic since STAR aligner will give a different class
    // rather a class should be AlignerConfig class, that returns appropriate config file

    //TODO I shouldn't be instantiation new Samples class in here, instead as per sikSampleClass.bds line 171, I should pre-parse fastq file into Sample calss
    // and AlingerResults should simply take Sample[] samples as an argument. That will be much cleaner
    void AlignerResults(Sample[] samples, string aligner, AlignerConfig alignerConf, string genomeIdx, string[] idxDeps) {

        switch(aligner) {
            case 'star':
                for(Sample s : samples) {
                    Sample result = mapSTAR(alignerConf.sikStarAlignerConf, s, genomeIdx, idxDeps)
                    this.results.add(result)
                }
                break
            case 'hisat2':
                error("SikErr: Haven't been implemented yet")
                break
            case 'bwaMem':
                for(Sample s : samples) {
                    Sample result = mapBWA(alignerConf.sikBWAalignerConf, s, genomeIdx, idxDeps)
                    this.results.add(result)
                }
                break
            default:
                error("SikErr: There needs to be an error here to make sure nothing else is passed through, other than allowed aligners")
        }

        string[] starGoals

        for(Sample s : results) {
            starGoals.add(s.bams.bamAlignerLog)
        }

        goal starGoals
    }
}

class SortedBamResults {
   //TODO Return bam files, sorted and if flaged mdups. These are the bams that moving forward for counting and the rest of the analysis

    Sample[] results

    void SortedBamResults(Sample[] alignerResults, SikConfig sikConf, SortConfig sortConf) {

        string sikDir = sikConf.sikCmdFlags{"outDir"}
        string mdups = getVal(sikConf.sikCmdFlags, "mdups")
        string sortingTool = "samtools" //TODO should really move this variable into sikConf

        switch(sortingTool) {
            case 'samtools':
                for(Sample s : alignerResults) {
                    Sample result = doBamSort(s, sortConf.samtoolsSortConf)
                    results.add(result)
                }
                break
            case 'picard':
                error("SikErr: Haven't been implemented yet")
                break
            default:
                error("SikErr: There needs to be an error here to make sure nothing else is passed through, other than allowed aligners")
        }

        string[] bamGoals

        if(mdups == "default") {
            for(Sample s : results) {
                bamGoals.add(s.bams.bamSortedMdupsMetrics)
                bamGoals.add(s.bams.bamSortedMdupsOut)
                bamGoals.add(s.bams.bamSortedMdupsIdx)
            }
        } else if(mdups == "umi") {
            for(Sample s : results) {
                bamGoals.add(s.bams.bamSortedMdupsUmiMetrics)
                bamGoals.add(s.bams.bamSortedMdupsUmiOut)
                bamGoals.add(s.bams.bamSortedMdupsUmiIdx)
            }
        } else {
            for(Sample s : results) {
                bamGoals.add(s.bams.bamSortedLog)
                bamGoals.add(s.bams.bamSortedOut)
                bamGoals.add(s.bams.bamSortedIdx)
            }
        }

        goal bamGoals
    }
}

class MarkDupsBamResults {

    Sample[] results

    void MarkDupsBamResults(Sample[] sortedBamResults, SikConfig sikConf, MarkDupsConfig mdupsConf) {

        string sikDir = sikConf.sikCmdFlags{"outDir"}
        //TODO mdups should be a string either classic or umi based reads de-duplication
        // maybe better to call "classic" default, since most of bulk RNAseq is default?
        string mdups = getVal(sikConf.sikCmdFlags, "mdups")

        if(mdups != "NULL") mdups = mdups.toLower()

        switch(mdups) {
            case 'default':
                for(Sample s : sortedBamResults) {
                    Sample result = doBamMarkDups(s, mdupsConf, sikDir)
                    results.add(result)
                }
                break
            case 'umi':
                for(Sample s : sortedBamResults) {
                    Sample result = doBamMarkDupsUmi(s, mdupsConf, sikDir)
                    results.add(result)
                }
                break
            case 'none':
                warning("SikErr: No reads de-duplication will occur. If you want to de-deplicate your data use mdups = 'default'")
                break
            default:
                //error("SikErr: There needs to be an error here to make sure nothing else is passed through, other than allowed aligners")
                //TODO I think it's okay to silently pass through here, since I'm handling flow of bam files in the main RNAsik.bds file
                // here I just want to make sure I do approptiate function call for de-duplication
                break
        }

        string[] bamGoals

        if(mdups == "default") {
            for(Sample s : results) {
                bamGoals.add(s.bams.bamSortedMdupsMetrics)
                bamGoals.add(s.bams.bamSortedMdupsOut)
                bamGoals.add(s.bams.bamSortedMdupsIdx)
            }
        } else if(mdups == "umi") {
            for(Sample s : results) {
                bamGoals.add(s.bams.bamSortedMdupsUmiMetrics)
                bamGoals.add(s.bams.bamSortedMdupsUmiOut)
                bamGoals.add(s.bams.bamSortedMdupsUmiIdx)
            }
        }

        goal bamGoals
    }
}

class ReadCountsResults {

    Sample[] counts

    void ReadCountsResults(Sample[] bamResults, string geneModels, string sikDir, SikCountsConfig sikCntsConf) {

        for(Sample s : bamResults) {
            Sample count = doReadCounts(s, sikCntsConf, geneModels, sikDir)
            counts.add(count)
        }

        string[] countFilesIn
        string[] summaryFilesIn
        string[] countFilesLogs

        for(Sample s : counts) {
            countFilesIn.add(s.counts.cntsNon)
            summaryFilesIn.add(s.counts.cntsNonSummary)
            countFilesLogs.add(s.counts.cntsNonLog)

            countFilesIn.add(s.counts.cntsFwd)
            summaryFilesIn.add(s.counts.cntsFwdSummary)
            countFilesLogs.add(s.counts.cntsFwdLog)

            countFilesIn.add(s.counts.cntsRev)
            summaryFilesIn.add(s.counts.cntsRevSummary)
            countFilesLogs.add(s.counts.cntsRevLog)
        }

        //string[] countsGoals

        //countsGoals += countFilesIn
        //countsGoals += summaryFilesIn
        //countsGoals += countFilesLogs

        //goal countsGoals
        goal countFilesLogs

        ReadCounts readCounts = new ReadCounts(counts[0].counts.countsDir, countFilesIn, summaryFilesIn)

        string[] readCountFilesGoals

        readCountFilesGoals.add(readCounts.cntsFwd)
        readCountFilesGoals.add(readCounts.cntsRev)
        readCountFilesGoals.add(readCounts.cntsNon)

        goal readCountFilesGoals

        string[] readCountSummaryGoals

        readCountSummaryGoals.add(readCounts.cntsFwdSummary)
        readCountSummaryGoals.add(readCounts.cntsRevSummary)
        readCountSummaryGoals.add(readCounts.cntsNonSummary)

        goal readCountSummaryGoals

    }
}

class QcResults {

    Sample[] fastqcRes
    Sample[] samtoolsQcRes

    void QcResults(Sample[] sample, QcConfig qcConf) {

        for(Sample s : sample) {
            Sample fastqc = doFastQc(s, qcConf.fastqcConf)
            fastqcRes.add(fastqc)

            Sample samtoolsQc = doSamtoolsQc(s, qcConf.samtoolsQcConf)
            samtoolsQcRes.add(samtoolsQc)
        }

        string[] fastqcGoals

        for(Sample s : fastqcRes) {
            fastqcGoals.add(s.qc.fastqc.fastqcHtmlR1)
            fastqcGoals.add(s.qc.fastqc.fastqcHtmlR2)
            fastqcGoals.add(s.qc.fastqc.fastqcZipR1)
            fastqcGoals.add(s.qc.fastqc.fastqcZipR2)
        }

        goal fastqcGoals

        string[] samtoolsQcGoals

        for(Sample s : samtoolsQcRes) {
            samtoolsQcGoals.add(s.qc.samtoolsQc.flagstatFn)
            samtoolsQcGoals.add(s.qc.samtoolsQc.idxstatsFn)
        }

        goal samtoolsQcGoals
    }
}
