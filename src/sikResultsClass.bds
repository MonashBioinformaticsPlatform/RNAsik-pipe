
class AlignerResults {

    Sample[] results
    //TODO this a bug, this class takes sikBWAalignerConfig class, however it needs to be generic since STAR aligner will give a different class
    // rather a class should be AlignerConfig class, that returns appropriate config file

    //TODO I shouldn't be instantiation new Samples class in here, instead as per sikSampleClass.bds line 171, I should pre-parse fastq file into Sample calss
    // and AlingerResults should simply take Sample[] samples as an argument. That will be much cleaner
    void AlignerResults(Sample[] samples, string aligner, AlignerConfig alignerConf, string genomeIdx, string[] idxDeps) {

        switch(aligner) {
            case 'star':
                for(Sample s : samples) {
                    Sample result = mapSTAR(alignerConf.sikStarAlignerConf, s, genomeIdx, idxDeps)
                    this.results.add(result)
                }
                break
            case 'hisat2':
                error("SikErr: Haven't been implemented yet")
                break
            case 'bwaMem':
                for(Sample s : samples) {
                    Sample result = mapBWA(alignerConf.sikBWAalignerConf, s, genomeIdx, idxDeps)
                    this.results.add(result)
                }
                break
            default:
                error("SikErr: There needs to be an error here to make sure nothing else is passed through, other than allowed aligners")
        }

        string[] starGoals

        for(Sample s : results) {
            starGoals.add(s.bams.bamAlignerLog)
        }

        goal starGoals
    }
}

class SortedBamResults {
   //TODO Return bam files, sorted and if flaged mdups. These are the bams that moving forward for counting and the rest of the analysis

    Sample[] results

    void SortedBamResults(Sample[] alignerResults, SikConfig sikConf, SortConfig sortConf) {

        string sikDir = sikConf.sikCmdFlags{"outDir"}
        string mdups = getVal(sikConf.sikCmdFlags, "mdups")
        string sortingTool = "samtools" //TODO should really move this variable into sikConf

        switch(sortingTool) {
            case 'samtools':
                for(Sample s : alignerResults) {
                    Sample result = doBamSort(s, sortConf.samtoolsSortConf, sikDir)
                    results.add(result)
                }
                break
            case 'picard':
                error("SikErr: Haven't been implemented yet")
                break
            default:
                error("SikErr: There needs to be an error here to make sure nothing else is passed through, other than allowed aligners")
        }

        string[] bamGoals

        if(mdups == "default") {
            for(Sample s : results) {
                bamGoals.add(s.bams.bamSortedMdupsMetrics)
                bamGoals.add(s.bams.bamSortedMdupsOut)
                bamGoals.add(s.bams.bamSortedMdupsIdx)
            }
        } else if(mdups == "umi") {
            for(Sample s : results) {
                bamGoals.add(s.bams.bamSortedMdupsUmiMetrics)
                bamGoals.add(s.bams.bamSortedMdupsUmiOut)
                bamGoals.add(s.bams.bamSortedMdupsUmiIdx)
            }
        } else {
            for(Sample s : results) {
                bamGoals.add(s.bams.bamSortedLog)
                bamGoals.add(s.bams.bamSortedOut)
                bamGoals.add(s.bams.bamSortedIdx)
            }
        }

        goal bamGoals
    }
}

class MarkDupsBamResults {

    Sample[] results

    void MarkDupsBamResults(Sample[] sortedBamResults, SikConfig sikConf, MarkDupsConfig mdupsConf) {

        string sikDir = sikConf.sikCmdFlags{"outDir"}
        //TODO mdups should be a string either classic or umi based reads de-duplication
        // maybe better to call "classic" default, since most of bulk RNAseq is default?
        string mdups = getVal(sikConf.sikCmdFlags, "mdups")

        if(mdups != "NULL") mdups = mdups.toLower()

        switch(mdups) {
            case 'default':
                for(Sample s : sortedBamResults) {
                    Sample result = doBamMarkDups(s, mdupsConf, sikDir)
                    results.add(result)
                }
                break
            case 'umi':
                for(Sample s : sortedBamResults) {
                    Sample result = doBamMarkDupsUmi(s, mdupsConf, sikDir)
                    results.add(result)
                }
                break
            case 'none':
                warning("SikErr: No reads de-duplication will occur. If you want to de-deplicate your data use mdups = 'default'")
                break
            default:
                //error("SikErr: There needs to be an error here to make sure nothing else is passed through, other than allowed aligners")
                //TODO I think it's okay to silently pass through here, since I'm handling flow of bam files in the main RNAsik.bds file
                // here I just want to make sure I do approptiate function call for de-duplication
                break
        }

        string[] bamGoals

        if(mdups == "default") {
            for(Sample s : results) {
                bamGoals.add(s.bams.bamSortedMdupsMetrics)
                bamGoals.add(s.bams.bamSortedMdupsOut)
                bamGoals.add(s.bams.bamSortedMdupsIdx)
            }
        } else if(mdups == "umi") {
            for(Sample s : results) {
                bamGoals.add(s.bams.bamSortedMdupsUmiMetrics)
                bamGoals.add(s.bams.bamSortedMdupsUmiOut)
                bamGoals.add(s.bams.bamSortedMdupsUmiIdx)
            }
        }

        goal bamGoals
    }
}

class ReadsCount {

    Sample[] counts

    void ReadsCount(Sample[] bamResults, string geneModels, string sikDir, SikCountsConfig sikCntsConf) {

        for(Sample s : bamResults) {
            Sample count = doReadsCount(s, sikCntsConf, geneModels, sikDir)
            counts.add(count)
        }

        string[] readCntsGoals

        for(Sample s : counts) {
            readCntsGoals.add(s.counts.cntsNon)
            readCntsGoals.add(s.counts.cntsNonLog)
            readCntsGoals.add(s.counts.cntsFwd)
            readCntsGoals.add(s.counts.cntsFwdLog)
            readCntsGoals.add(s.counts.cntsRev)
            readCntsGoals.add(s.counts.cntsRevLog)
        }

        goal readCntsGoals

    }
}

class FastQcResults {

    Sample[] results

    void FastQcResults(Sample[] sample, FastQcConfig fastqcConf, bool qc) {

        for(Sample s : sample) {
            Sample fastqc = doFastQc(s, fastqcConf, qc)
            results.add(fastqc)
        }

        string[] fastqcGoals

        for(Sample s : results) {
            fastqcGoals.add(s.fastqc.fastqcHtmlR1)
            fastqcGoals.add(s.fastqc.fastqcHtmlR2)
            fastqcGoals.add(s.fastqc.fastqcZipR1)
            fastqcGoals.add(s.fastqc.fastqcZipR2)
        }

        goal fastqcGoals

    }
}
