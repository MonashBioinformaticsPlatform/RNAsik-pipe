#!/usr/bin/env bds

#----------------------------------------------------------------------------------------------------
# RNAsik-pipe is an easy way from FASTQ to differential gene expression #degust
#----------------------------------------------------------------------------------------------------

#------------------------------
#  Serine #MonashFlavour
#------------------------------

#----------------------------------------------------------------------------------------------------
#
#    About RNAsik-pipe
#
#   * Takes a whole directory with FASTQ files
#   * Understands if FASTQ files are paired end or single end
#   * Understands if samples span different lanes. Merges all sample's lane at the STAR runtime
#   * Gets count data, checks both reverse strand and no strands 
#   * Prepares BAM files for RNAseQC report
#   * Gets both RNA-SeQC report and Fastqc report
#
#----------------------------------------------------------------------------------------------------

include "sikHeader.bds"
include "sikSanityCheck.bds"
include "sikMakeIndices.bds"
include "sikFunctions.bds" 
include "sikPrePro.bds"
include "sikCounts.bds"
include "sikQCreports.bds"

#------------------------------
# Make indices if required 
#------------------------------
if(makeIndices){
    localFastaRef = makeLocalFastaRef(fastaRef)
    string sjdbArguments
    if(gtfFile) {
        int readSize = 101
        int overHang = readSize - 1
    
        sjdbArguments = "--sjdbGTFfile $gtfFile --sjdbOverhang $overHang"
    }
    else sjdbArguments = ""
    string[] localIndexList = makeSTARindex(localFastaRef, sjdbArguments)
    localSAindexFile = localIndexList[0]
    localGenomeIndex = localIndexList[1]
    string fastaFaiFile = makeOtherIndices(localFastaRef)
}

if(makeIndex){

    string fastaFaiFile = makeOtherIndices(localFastaRef)
}
#------------------------------
# fastQC report
#------------------------------
if(fastqc) {
    if(!fqDir.isEmpty()) {
        string fqcReport = getFastqcReport(fqDir)
    }
    if(!fqDirs.isEmpty()) {
        string[] dirs = getDirs(fqDirs)
        int numberOfDirs = dirs.size()

        for(int i=0; i < numberOfDirs; i++){
            string dir = dirs[i]
            string fqcReport = getFastqcReport(dir)
        }
    }
}
#------------------------------
# BAM generation step
#------------------------------
if(star){
    if(!fqDir.isEmpty()) {
        string{} uniqueNames = getUniqueNames(fqDir)

        for(string fqread : uniqueNames.keys()) {
            # get value for each key and break values into list
            string mapValue = uniqueNames{fqread} 
            string[] getList = mapValue.split(",")
            string[] orderedList = getOrderedList(getList)
            string boolItem = orderedList.pop()
            checkPair = boolItem.parseBool()
            # STAR aligning
            string[] reads = getSTARreads(orderedList, checkPair)
            string bamFile = mapSTAR(fqread, localGenomeIndex, localSAindexFile, reads, orderedList) 
            bamsList.add(bamFile)
        }
    }

    if(!fqDirs.isEmpty()) {
        string[] dirs = getDirs(fqDirs)
        int numberOfDirs = dirs.size()
    
        for(int i=0; i < numberOfDirs; i++){
        
            string dir = dirs[i]
            string{} uniqueNames = getUniqueNames(dir)
    
            for(string fqread : uniqueNames.keys()) {
                # get value for each key and break values into list
                string mapValue = uniqueNames{fqread} 
                string[] getList = mapValue.split(",")
                string[] orderedList = getOrderedList(getList)
                string boolItem = orderedList.pop()
                checkPair = boolItem.parseBool()
                # STAR aligning
                string[] reads = getSTARreads(orderedList, checkPair)
                string bamFile = mapSTAR(fqread, localGenomeIndex, localSAindexFile, reads, orderedList) 
                bamsList.add(bamFile)
            }
        }
    }
}

string featureNoCounts = "featureNoCounts.txt"
string featureReversCounts = "featureReversCounts.txt"

if(count) {
   string[] featureCounts = getReadsCount(bamsList, gtfFile, checkPair)

   string countsNo = featureCounts[0]
   string countsRevers = featureCounts[1]

   int numberOfBamFiles = bamsList.size()+7
   int[] theRange = range(7, numberOfBamFiles)
   string numberOfFields = theRange.join(",")

   task([featureNoCounts, featureReversCounts] <- featureCounts, taskName := "back massage") {
       sys grep -v "#" $countsNo | cut -f1,$numberOfFields | perl -pe 's{\S+/([^_]+)[^/]+(\t|\n)}{$1$2}g if $. == 1' > $featureNoCounts
       sys grep -v "#" $countsRevers | cut -f1,$numberOfFields | perl -pe 's{\S+/([^_]+)[^/]+(\t|\n)}{$1$2}g if $. == 1' > $featureReversCounts
   }
   goal featureCounts
}
#------------------------------
# BAM processing
#------------------------------
for(string bamFile : bamsList) {
    if(prePro) {
        string testCheck = getPrePro(bamFile, localFastaRef)
        markedBams.add(testCheck)
    }
}
#----------------
# RNAseQC report
#----------------
if(RNAseQC){
    string sampleIdsFile = "RNAseQC-sampleIds.txt"
    string RNAseQCsampleIds = getSampleIds(markedBams)
    sampleIdsFile.write(RNAseQCsampleIds)
    string check = getRNAseQC(sampleIdsFile, markedBams, checkPair, localFastaRef)
}
#----------------------------------------------------------------------------------------------------
# End
#----------------------------------------------------------------------------------------------------
