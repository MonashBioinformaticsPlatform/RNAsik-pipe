/*
STAR aligner objects
*/

include "sikConfigClass.bds"
include "sikSTARutils.bds"

// NOTE This class is the one I want to pass around. It should have all necessary parameters for the tool execution
// In general it now becomes relativelly easy to extend RNAsik with new aligner, simply add a class for your aligner of choice
// in this case STAR
// Class methods:
// - toolExe
// - alignerCpu
// - alignerMem
// - mkIdxCpu
// - mkIdxMem
// - toolArgs

class SikStarIdxConfig extends SikResourcesConfig {

    string{} idxRes
    string[] idxCmdOpts

    string{} _sikStarIdxConf // private to this class

    void SikStarIdxConfig(string{} usrResConf, string{} usrToolsConf) {

        SikResourcesConfig(usrResConf)

        string{} usrStarIdxOpts

        if(usrToolsConf.hasKey("starIdx")) {
            usrStarIdxOpts = parseUsrToolsOpts("starIdx", usrToolsConf{"starIdx"})
        }

        string sikStarIdxConfigFn = this._configOriginFn + "/sikCmdOptions/starIdx.config"
        assert(sikStarIdxConfigFn.exists())
        this._sikStarIdxConf = config(sikStarIdxConfigFn)

        string[] keys = this._sikStarIdxConf.keys()
        keys += usrStarIdxOpts.keys()
        keys = unique(keys)

        for(string k : keys) {
            if(usrStarIdxOpts.hasKey(k)) {
                idxCmdOpts.add([k, usrStarIdxOpts{k}].join(" "))
            } else {
                idxCmdOpts.add([k, this._sikStarIdxConf{k}].join(" "))
            }
        }

        string[] sanityChk = ["starIdxCpu", \
                              "starIdxMem", \
                              "starExe"]

        for(string k : sanityChk) {
            if(!this._sikResConf.hasKey(k)) {
                error "\n\
                       \n\
                       SikErr: Key not found -> $k. Check you configuration files \
                       \n"
            }
        }

        idxRes{"idxCpu"} = this._sikResConf{"starIdxCpu"}
        idxRes{"idxMem"} = this._sikResConf{"starIdxMem"}
        idxRes{"starExe"} = this._sikResConf{"starExe"}

    }
}

class SikStarAlignerConfig extends SikResourcesConfig {
/*

DOCS: This class takes, takes global sikRefConf that holds information about all required resources and usrStarConf information which is anything that
user specified and adjusted for STAR to work with. The SikStarConfig can then be passed to STAR indexing and alignment. Main objects from this class are:

- alignerRes
- alignerCmdOpts

AND

- idxRes
- idxCmdOpts

FYI:
The following keys are removed from allowed keys

--runMode: is special and set internally only
--runThread and --runThreadN: are resource keys, they set through different avenue via sik.config starAlingerCpu and starAlignerMem
--outFileNamePrefix: this is sample specific and is set via samples sheet
--genomeDir: this is set internally in RNAsik, no need to set it externally
--genomeFastaFiles: as per --genomeDir

NOTE
As far as index specific keys goes, I think there is only --genomeSAindexNbases and --genomeChrBinNbits
all other keys can be included either at the mapping or indexing step. I guess it would be important to know how the reference was made
*/
    string{} alignerRes
    string[] alignerCmdOpts

    string{} _sikStarAlignerConf // private to this class

    void SikStarAlignerConfig(string{} usrResConf, string{} usrToolsConf) {

        SikResourcesConfig(usrResConf)

        string{} usrStarAlignerOpts

        if(usrToolsConf.hasKey("starAligner")) {
            usrStarAlignerOpts = parseUsrToolsOpts("starAligner", usrToolsConf{"starAligner"})
        }

        string sikStarAlignerConfigFn = this._configOriginFn + "/sikCmdOptions/starAligner.config"
        assert(sikStarAlignerConfigFn.exists())
        this._sikStarAlignerConf = config(sikStarAlignerConfigFn)

        string[] keys = this._sikStarAlignerConf.keys()
        keys += usrStarAlignerOpts.keys()
        keys = unique(keys)

        for(string k : keys) {

            //TODO should check for aberant characters in the opts string e.g : or - or _ or ,
            // something that user might have passed in accidently that causes downstream error
            if(usrStarAlignerOpts.hasKey(k)) {
                alignerCmdOpts.add([k, usrStarAlignerOpts{k}].join(" "))
            } else {
                alignerCmdOpts.add([k, this._sikStarAlignerConf{k}].join(" "))
            }
        }

        string[] sanityChk = ["starAlignerCpu", \
                              "starAlignerMem", \
                              "starExe"]

        for(string k : sanityChk) {
            if(!this._sikResConf.hasKey(k)) {
                error "\n\
                       \n\
                       SikErr: Key not found -> $k. Check you configuration files \
                       \n"
            }
        }

        alignerRes{"alignerCpu"} = this._sikResConf{"starAlignerCpu"}
        alignerRes{"alignerMem"} = this._sikResConf{"starAlignerMem"}
        alignerRes{"starExe"} = this._sikResConf{"starExe"}
    }
}

class StarIndex {

    string genomeIdx
    string[] idxDeps

    void StarIndex(SikStarIdxConfig sikStarIdxConf, string fasta, string refDir, string genomeIdx) {

        string extn = fasta.extName()
        string starIdxDir
        string logFn

        //TODO would be useful to stick aligner version to the suffix as well in future
        if(extn == "gz") {
            starIdxDir = refDir + "/" + fasta.baseName().removeExt().removeExt() + ".starIdx"
            logFn = refDir + "/" + "." + fasta.baseName().removeExt().removeExt() + ".starIdx.siklog"
        } else {
            starIdxDir = refDir + "/" + fasta.baseName().removeExt()+".starIdx"
            logFn = refDir + "/" + "." + fasta.baseName().removeExt() + ".starIdx.siklog"
        }

        log("MSG: Making STAR genomic index directory $starIdxDir")
        if(!starIdxDir.exists()) {
            starIdxDir.mkdir()
        }

        string[] idxFiles = ["chrLength.txt", "chrNameLength.txt", "chrName.txt", "chrStart.txt", "Genome", "genomeParameters.txt", "SA", "SAindex"]
        for(string idxFile : idxFiles) {
            string idxDep = starIdxDir + "/" + idxFile
            this.idxDeps.add(idxDep)
        }

        /*
            TODO this isn't ideal, but in my ReferenceFiles class I'm attempting to set genomeIdx variable
            which can come about in three different ways:
                - via refFiles variable, in which case RNAsik will pick it up and set genomeIdx
                - direct user input, via genomeIdx = /path/to/index
                - in the last resort RNAsik will simply make genomeIdx as per specified aligner
            unfortunatelly BDS doesn't seem to have a way to set a variable to NULL. So if user didn't specify genomeIdx in they config
            then I cope an error when trying to check for that key.
            I think I know what the right solution should be - my SikConfig class should check for all missing keys and set them accordingly,
            that way they key will either be present of empty and I can always check with .isEmpty() call
        */
        if(genomeIdx == "NULL" || genomeIdx.isEmpty()) {
            this.genomeIdx = mkSTARidx(sikStarIdxConf, fasta, refDir, starIdxDir, idxDeps, logFn)
        } else {
            assert(genomeIdx.exists())
            this.genomeIdx = genomeIdx
        }
    }
}

//class StarAlinment {
//   // NOTE this will yeild bamFiles
//}
