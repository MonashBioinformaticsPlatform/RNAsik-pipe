#------------------------
# Organising FASTQ files 
#------------------------
string getTarDir(string tarFile, string sikDir) {

    string getExtn = tarFile.extName()
    string tarDir = sikDir+"/"+"fastqDir"
    if(!tarDir.exists()) tarDir.mkdir()
    //string tarName = sikDir+"/"+tarFile.baseName()
    //bool tarOk = tarFile.download(tarName)
    string tarRef = tarFile.download()
    string[] argsList = ["-x", "-f"]
    if(getExtn == "gz") argsList.add("-z")
    string tarArgs = argsList.join(" ")
    //NOTE need to think about smartter dependencies, maybe there is a way to get rid of wait statement 
    task(tarDir <- tarRef, taskName := "unarchiving $tarRef to $tarDir") sys tar $tarArgs $tarRef -C $tarDir
    wait
    return tarDir
}

string[] getFqFiles(string fqDir, string extn, string sikDir) {

    int chkHttp = fqDir.toLower().indexOf("http:")
    if(chkHttp != -1) fqDir = getTarDir(fqDir, sikDir)

    string[] originDir = fqDir.dirPath() 
    if(originDir.isEmpty()) error "No FASTQ file found, check -fqDir option"
    string[] fqFiles
    // go through each file and check if its file or directory
    //TODO the if block is temporal measure due to BDS bug, is getting fixed I hope
    if(!fqDir.isEmpty()) {
        //for(string dir : fqDir.dirPath()){
        for(string dir : originDir){
            // check if dir is directory and call getFqFiles on it
            if(dir.isDir()) fqFiles += getFqFiles(dir, extn, sikDir)
            // otherwise check if dir is FASTQ file and append it to the fqFiles
            else if(dir.endsWith(extn)) fqFiles.add(dir)
        }
    }
    // return fqFiles array
    return fqFiles
}
string getKey(string fq, string samplesSheet) {
    if(samplesSheet.isEmpty()) error "-samplesSheet is empty"
    string{} samples = config(samplesSheet)
    string[] prefixes = samples.keys()
    prefixes = prefixes.sort().reverse()
    for(string prefix : prefixes) {
        bool chk = fq.baseName().startsWith(prefix)
        if(chk) return samples{prefix}
    }
    error "No prefix was found for this $fq file"
}
// given a file name return rootName
string getRootName(string fq, string fqRegex, string samplesSheet, string extn) {
    // if fqRegex is given use that
    if( (!samplesSheet.isEmpty()) || ( (!samplesSheet.isEmpty()) && (!fqRegex.isEmpty()) ) ) {
        return getKey(fq, samplesSheet)
    }
    else {
        if(!fqRegex.isEmpty()) {
            string[] tmp = fq.split(fqRegex)
            string rootName = tmp[0].baseName()
            if(tmp[0] == fq) error "It appears that your fqRegex didn't work. Double check your fqRegex"
            return rootName
        }
        // if no fqRegex is given and r1Idx was found
        // fall back to splicing rootName from start to the r1Idx
        else {
            // check if R1 is in the file name
            int oneIdx = fq.lastIndexOf("_R1")
            int twoIdx = fq.lastIndexOf("_R2")

            if(oneIdx != -1) return fq.substr(0, oneIdx).baseName()
            if(twoIdx != -1) return fq.substr(0, twoIdx).baseName()
            // if all of the above failed
            // use simply remove extn from the file and use that as a rootName
            if( (oneIdx == -1) && (twoIdx == -1) ) return fq.baseName(extn)
        }
    }
}
// This function return hash with key set to root name 
// and value is the list of all associated FASTQ files
// that are spread across multiple lane during sequencing
string{} getFqMap(string[] fqFiles, string fqRegex, string samplesSheet, string extn) {
    if(fqFiles.isEmpty()) error "getFqFiles function retuned nothing, something up with -fqDir parameter, check FASTQ file extention and pass correct -extn value maybe?"
    // Map with unique root key
    string{} fqMap
    // loop over FASTQ files
    for(string fq : fqFiles) {
	// sometimes fastq directory also holds indices files
        // don't use those index files !
	int chkIdxFile = fq.lastIndexOf("_I1")
 	if(chkIdxFile == -1) {
            string rootName = getRootName(fq, fqRegex, samplesSheet, extn)
            if(!fqMap.hasKey(rootName)) fqMap{rootName}=""
            fqMap{rootName}+=fq+","
        }
    }
    return fqMap
}
//
string[] getReads(string fqVal) {
    // remove trailing comma from the string, side effect from fqMap
    string cleanFq = fqVal.substr(0, (fqVal.length())-1)
    string[] fqList = cleanFq.split(",")
    int odd = fqList.size() % 2
    
    string[] rTwo
    if(odd == 1) return [fqList.join(",")]
    // double check that you have paired-end data
    // if no _R2 sub-string found in the string data assumed to be single-end
    if(cleanFq.lastIndexOf("_R2") != -1) {
        for(int i=0; i < fqList.size(); i++) {
           rTwo.push(fqList.removeIdx(i+1)) 
        }
        return [fqList.join(","), rTwo.join(",")]

    } 
    else return [fqList.join(",")]
}
//
bool getPaired(string[] reads) {
    if( (reads.size() < 1) || (reads.size() > 2) ) error "This error shouldn't happened. Something went wrong with your reads, check sikFqFiles.bds file"
    if(reads.size() == 2) return true
    else return false
}
