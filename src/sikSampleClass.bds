class Metadata {

    string sampleName
    string sampleGroup
    string[] fq1
    string[] fq2
    bool paired
    //string readGroup TODO future implementation

    void Metadata(string[] sampleData) {

        //TODO check if the sample is paired end and set paired flag accordingly
        //Potentially can process paired and single end data together in the future
        //this.paired = paired

        assert("SikErr: Unexpected number of items ->\n" + sampleData.join("\n"), sampleData.size() == 4)

        this.sampleName = sampleData[0]
        this.sampleGroup = sampleData[1]
        this.fq1 = sampleData[2].split(",")
        this.fq2 = sampleData[3].split(",")

        if(fq1.size() == fq2.size() && fq2.size() > 0) {
            this.paired = true
        }

    }
}

class BamsGeneric {

    string bamOut
    string bamIdx
    string bamLog

    void BamsGeneric(string sampleName, string sikDir) {

        //log("MSG: Output directory $sikDir") //too noise

        string alignDir = sikDir+"/"+"alignerFiles"
        //log("MSG: Making directory for alignment files $alignDir") //too noisy
        if(!alignDir.exists()) {
            alignDir.mkdir()
        }

        this.bamOut = alignDir + "/" + sampleName + ".bam"
        this.bamIdx = alignDir + "/" + sampleName + ".bai"
        this.bamLog = alignDir + "/." + sampleName + ".siklog"
    }
}

class Bams extends BamsGeneric {

    string bamAlignerOut
    string bamAlignerLog

    string bamSortedOut
    string bamSortedIdx
    string bamSortedLog

    string bamSortedMdupsOut
    string bamSortedMdupsIdx
    string bamSortedMdupsLog
    string bamSortedMdupsMetrics

    void Bams(string sampleName, string sikDir, string aligner) {
        //log("MSG: Aligner type $aligner") //too noisy

        BamsGeneric(sampleName, sikDir)

        string bamFilesDir = sikDir+"/"+"bamFiles"
        if(!bamFilesDir.exists()) {
            bamFilesDir.mkdir()
        }

        switch(aligner) {
            case 'star':
                this.bamAlignerOut = this.bamOut.replace(".bam", "_Aligned.out.bam")
                this.bamAlignerLog = this.bamLog.replace(".siklog", "_Aligner.out.bam.siklog")

                this.bamSortedOut = bamFilesDir + "/" + this.bamOut.baseName().replace(".bam", "_sorted.bam")
                this.bamSortedIdx = bamFilesDir + "/" + this.bamIdx.baseName().replace(".bai", "_sorted.bai")
                this.bamSortedLog = bamFilesDir + "/" + this.bamLog.baseName().replace(".siklog", "_sorted.bam.siklog")

                this.bamSortedMdupsOut = this.bamSortedOut.replace(".bam", "_mdups.bam")
                this.bamSortedMdupsIdx = this.bamSortedIdx.replace(".bai", "_mdups.bai")
                this.bamSortedMdupsLog = this.bamSortedLog.replace(".bam.siklog", "_mdups.bam.siklog")
                this.bamSortedMdupsMetrics = this.bamSortedOut.replace(".bam", "_mdups.metrics")

                break
            case 'hisat2':
                this.bamOut = this.bamOut.replace(".bam", "_aligned.bam")
                this.bamLog = this.bamLog.replace(".siklog", "_aligned.log")
                break

            case 'bwaMem':
                this.bamAlignerOut = this.bamOut.replace(".bam", "_bwaMem.bam")
                this.bamAlignerLog = this.bamLog.replace(".siklog", "_bwaMem.siklog")

                this.bamSortedOut = bamFilesDir + "/" + this.bamOut.baseName().replace(".bam", "_sorted.bam")
                this.bamSortedLog = bamFilesDir + "/" + this.bamLog.baseName().replace(".siklog", "_sorted.bam.siklog")

                this.bamSortedMdupsOut = this.bamSortedOut.replace(".bam", "_mdups.bam")
                this.bamSortedMdupsLog = this.bamSortedLog.replace(".bam.siklog", "_mdups.bam.siklog")

                break
            default:
                error("SikErr: There needs to be an error here to make sure nothing else is passed through, other than allowed aligners")
        }
    }
}

class Counts {

    string cntsFwd
    string cntsFwdLog

    string cntsRev
    string cntsRevLog

    string cntsNon
    string cntsNonLog

    void Counts(string sampleName, string sikDir) {

        string countsDir = sikDir+"/"+"countFiles"
        if(!countsDir.exists()) {
            countsDir.mkdir()
        }

        this.cntsFwd = countsDir + "/" + sampleName + "_fwdCnts.txt"
        this.cntsFwdLog = countsDir + "/." + sampleName + "_fwdCnts.siklog"

        this.cntsRev = countsDir + "/" + sampleName + "_revCnts.txt"
        this.cntsRevLog = countsDir + "/." + sampleName + "_revCnts.siklog"

        this.cntsNon = countsDir + "/" + sampleName + "_nonCnts.txt"
        this.cntsNonLog = countsDir + "/." + sampleName + "_nonCnts.siklog"
    }
}

class Qc {

    string fastqc
    string flagstat
    string alignerStats
    string countsStats
    string multiqc

    void Qc() {

    }

}

class Sample {

    Metadata metadata
    Bams bams
    Counts counts
    Qc qc

    void Sample(string[] sampleData, string sikDir, string aligner) {

        this.metadata = new Metadata(sampleData)
        this.bams = new Bams(metadata.sampleName, sikDir, aligner)
        this.counts = new Counts(metadata.sampleName, sikDir)

    }
}

//TODO I'm realising that this class seem ambigious / confusing with Sample class above it. The two are very different classes.
// One meant to represent all of the computed data by RNAsik and the other simply abstracts away fastq file into samples
//NOTE I'm also now thinking that Samples shouldn't be a class at all. Instead it should be FastqProcessing() function call
// that in turn would populate Sample calss

class Samples {

    Sample[] samples

    //TODO it feels like there is weak error catching in parsing metadata file
    // for example if user forgot or misspelled on of the keys, this won't be catched,
    // the assertion in the Sample class should pick up the fact that list isn't 4 elements, not sure if this is good enought?
    void Samples(string metadataFn, string sikDir, string aligner) {

        assert("SikErr: Metadata file doesn't exist -> " + metadataFn, metadataFn.exists())
        string[] metadata = metadataFn.readLines()

        string prevName

        string[] sampleData
        string[] ones
        string[] twos

        for(string line : metadata) {

            line = line.trim()

            if(line.startsWith("#") || line.isEmpty())  {
                continue
            }

            string[] tokens = line.split(":")

            string k = tokens[0].trim()
            string v = tokens[1].trim()

            assert("SikErr: Line in metadata file doesn't have a valid key value pair -> " + line, tokens.size() == 2)

            if(k == "name") {

                if(!prevName.isEmpty() && prevName != v) {

                    sampleData.add(ones.join(","))
                    sampleData.add(twos.join(","))
                    Sample sample = new Sample(sampleData, sikDir, aligner)
                    this.samples.add(sample)

                    sampleData = []
                    ones = []
                    twos = []

                }

                prevName = v
                sampleData.add(0, v)

            } else if(k == "group") {
                sampleData.add(1, v)
            } else if(k == "r1") {
                assert("SikErr: R1 file doesn't exist -> " + v, v.exists())
                ones.add(v)
            } else if(k == "r2") {
                assert("SikErr: R2 file doesn't exist -> " + v, v.exists())
                twos.add(v)
            }

        }
        //TODO ugly code... is there a nicer way?
        if(!sampleData.isEmpty()) {
            sampleData.add(ones.join(","))
            sampleData.add(twos.join(","))
            Sample sample = new Sample(sampleData, sikDir, aligner)
            this.samples.add(sample)
       }
    }
}

