
string[] mkFastqc(string{} cmdExe, string sikDir, string[] fqFiles, string fqQcOpts, string extn) {

    string fastqcReport = sikDir+"/"+"fastqcReport"
    if((!fastqcReport.exists()) && (qc)) {
        fastqcReport.mkdir()
    }

    if( fqFiles.isEmpty() && qc ) {
        error "No FASTQ files found, use -fqDir /path/to/fastq/dir."
    }

    string{} resource = getResource(cmdExe, "fastqc", "")
    string fastqcExe = resource{"toolsExe"}
    int fastqcMem = resource{"toolsMem"}.parseInt()
    int fastqcCpu = resource{"toolsCpu"}.parseInt()

    string[] fqHtmls

    string preFix = "_fastqc.html"

    for(string fq : fqFiles) {
        string rootName = fq.baseName().removeExt(extn)
        string fqHtml = fastqcReport+"/"+rootName+preFix
        string logsFile = fastqcReport+"/."+rootName+".siklog"
        //NOTE this is a bit of hack where I assign 4 cpus for each task regardless of
        // threads values passed in. Also note that I'm setting --threads to 8. I don't fully
        // understand this, but by doing so fastqc gets Xmx2000m i.e 2G of heap memory for every task
        // and this flag -XX:ParallelGCThreads=1, which I get doesn't use any of the extra cpus
        // this is to speed up processing.
        // Basically on 16 core machines I'm allowing 4 parallel task to runs, each taking 2G of heap memory
        // and I think this is ok.. However in parallel there probably be also running another (multiple?) java process
        // that will also take up heap memory unknown amount.
        dep(qc, fqHtml <- fq, cpus := fastqcCpu, taskName := "Running FastQC on $fq and logging to $logsFile") {
            sys $fastqcExe $fqQcOpts --threads $fastqcCpu --outdir $fastqcReport $fq > $logsFile 2>&1
        }
        fqHtmls.add(fqHtml)
    }
    goal fqHtmls
    return fqHtmls
}
