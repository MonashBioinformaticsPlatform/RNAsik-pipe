#----------------------------------------
# Counts
#----------------------------------------
// runs python script `strand_guessing.py` that guess strandness of the data
string getStrandInfo(string{} cmdExe, string[] readCounts) {
    if(!cmdExe.hasKey("pythonExe")) error "Can't get python executable, check your config file $configFile"
    string pythonExe = cmdExe{"pythonExe"}

    string getProgPath = programPath.pathName()
    string pyScript = getProgPath+"/../scripts/strand_guessing.py"
    string countsDir = readCounts[0].dirName()
    string strandInfo = countsDir+"/"+"strandInfo.txt"
    task(counts, strandInfo <- readCounts, taskName := "getting strand info") {
        sys $pythonExe $pyScript --logsDir $countsDir > $strandInfo
    }
    // this is temp hack to stop mask function evaluation before above python script had run
    // because mask function has .read() on a file that doesn't exist yet.
    // I have to think about better solution for this OR "fix" multiqc to be able to handle multiple featureCounts files
    wait
    return mask(countsDir, strandInfo)
}
// once the strand had been guessed, mask two other .summary files
string mask(string countsDir, string strandInfo) {

    if(strandInfo.exists()) {
        string strandExitCode
        string strandType
        (strandType, strandExitCode) = strandInfo.read().split(",")

        strandType = strandType.trim() + ".txt.summary"

        for(string f : countsDir.dirPath("*.summary")){
            if(f.baseName() != strandType) {
                string masked = f.replace(".summary", ".summary.masked")
                task(counts, masked <- [f, strandInfo], taskName := "masking unwanted counts files") sys mv $f $masked 
            }
        }
        return strandInfo
    }
    //NOTE that this function if it drops into else block will return a bool false, BUT
    // because function is set to return "string" type you need to check it as though it is a string or use parseBool()
}

string[] getReadsCount(string{} cmdExe, string countFiles, string[] bamsList, string extraOpts, string localGTF, int threads) {

    if(!cmdExe.hasKey("countsExe")) error "Can't get featureCounts executable, check your config file $configFile"
    string countsExe = cmdExe{"countsExe"}

    if( (bamsList.isEmpty()) && (counts) ) error "No BAM files were found, either used -align options or specify directory with BAM files using `-bamFiles path/to/you/bams/directory`"

    string bamString = bamsList.join(" ")
    string[] allDeps = bamsList
    allDeps.add(localGTF)

    int chkPaired = extraOpts.indexOf("-p")
    if(chkPaired != -1 && !paired) error "featureCounts had been set for paired end data but -paired is unset $paired"
    if(chkPaired == -1 && paired) error "featureCounts hadn't been set for paired end data but -paired is set $paired"

    string[] featureOut
    string[] featureFiles = ["NonStrandedCounts.txt", "ForwardStrandedCounts.txt", "ReverseStrandedCounts.txt"]
    for(int i : range(0, 2)) {
        string countsName = countFiles+"/"+featureFiles[i]
        featureOut.add(countsName)
        dep(counts, countsName <- allDeps, taskName := "Counting features $countsName") {
            sys $countsExe -T 4 \
                           -s $i \
                           $extraOpts \
                           -o $countsName \
                           $bamString
        }
    }
    goal featureOut
    return featureOut
}
//
string getGeneIds(string pythonExe, string countFilesDir, string gtfFile, bool setGFF){
    string getProgPath = programPath.pathName()
    string pyFlag = '--gtfFile'
    if(setGFF){
        pyFlag = '--gffFile'
    }
    string pyScript = getProgPath+"/../scripts/getGeneIds.py"
    string geneIds = countFilesDir+"/"+"geneIds.txt"
    task(counts, geneIds <- gtfFile, taskName := "getting geneIds.txt file") {
        sys $pythonExe $pyScript $pyFlag $gtfFile > $geneIds
    }
    return geneIds
}

string[] getProteinCoding(string[] readCounts, bool setGFF) {

    string[] proteinCodingCounts

    for(string countFile : readCounts) {
        string proteinCoding = countFile.removeExt()+"-proteinCoding.txt"
        proteinCodingCounts.add(proteinCoding)
        //TODO need to include setGFF bool into dep OR check that protein_coding feature type is present
        dep(counts, proteinCoding <- countFile, taskName := "getting protein coding counts") {
            sys grep "Biotype" $countFile > $proteinCoding
            sys grep "protein_coding" $countFile >> $proteinCoding
        }
    }
    goal proteinCodingCounts
    return proteinCodingCounts
}

string[] getDegust(string{} cmdExe, string countFilesDir, string[] featureCounts, int bamsN, string gtfFile, bool gff, int threads) {
    if(!cmdExe.hasKey("pythonExe")) error "Can't get python executable, check your config file $configFile"
    string pythonExe = cmdExe{"pythonExe"}
    string geneIdsFile = getGeneIds(pythonExe, countFilesDir, gtfFile, gff)

    string[] withNames

    int bamConst = 7
    int lastBamN = bamsN+bamConst
    string cutRange = bamConst+"-"+lastBamN

    for(string countFile : featureCounts) {
        string withName = countFile.removeExt()+"-withNames.txt"
        withNames.add(withName)
        dep(counts, withName <- [countFile, geneIdsFile], taskName := "Degust-ready counts file", tmp := "$countFile.tmp", tmp2 := "$countFile.tmp2") {
            sys grep -v "#" $countFile | cut -f1,$cutRange | perl -pe 's{\S+/([^_]+)[^/]+(\t|\n)}{$1$2}g if $. == 1' > $tmp
            sys sed -i '0,/Geneid/s/Geneid/Gene.ID/' $tmp
            sys /bin/bash -c "join -j 1 <(sort -k1,1 $geneIdsFile) <(sort -k1,1 $tmp) -t $'\t' > $tmp2"
            sys grep "Biotype" $tmp2 > $withName
            sys grep -v "Biotype" $tmp2 >> $withName
            sys rm $tmp $tmp2
        }
    }
    goal withNames
        
    return getProteinCoding(withNames, gff)
}

