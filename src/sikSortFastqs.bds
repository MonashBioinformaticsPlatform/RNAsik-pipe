#------------------------
# Organising FASTQ files 
#------------------------
// This function loops over directory
// and returns list of FASTQ files
string[] getFastqFiles(string dir, string extn) {
    string[] fqFiles 

    for(string fq : dir.dirPath(extn)) {
    	fqFiles.add(fq)
    }
    return fqFiles
}
// This function return all FASTQ files found in the current directory
// and all sub directories
// only looks one level deep
string[] getAllFastqFiles(string fqDir, string extn) {
    string[] allFastqFiles
    # loop over all items in the current directory
    # and check if the item is the directory or a file
    for(string item : fqDir.dirPath()){
        bool dir = item.isDir()
        # if its a directory then apply `getFastqFiles` function
        if(dir) {
           string[] tmpFastqList = getFastqFiles(item, extn)
    
           for(string fq : tmpFastqList) {
               allFastqFiles.add(fq)
           } 
        }
        # otherwise check if the file is FASTQ file 
        # and append FASTQ file to a list
        else {
            bool fqFile = item.endsWith(extn)
            if(fqFile) {
                allFastqFiles.add(item)
            }
        }
    }
    # return all FASTQ file found
    return allFastqFiles
}
// This function fill fix FASTQ files prefix 
string getSampleName(string fqRoot, string samplesSheet) {
    // if smaplesSheet found, change prefix from old to new
    if(!samplesSheet.isEmpty()) {
        for(string line : samplesSheet.readLines()){
            string[] namesList = line.split("\t")
            string oldNamePrefix = namesList[0]
            string newNamePrefix = namesList[1]
            string preFixIndex = fqRoot.indexOf(oldNamePrefix)
            if(preFixIndex != -1){
                string fixedFileName = fqRoot.replace(oldNamePrefix, newNamePrefix)
                return fixedFileName
            }
        }
    }
    // if samplesSheet isn't found i.e isn't passed in through cmd line
    // then simply return original FASTQ file
    else return fqRoot
}
// takes fqMap, loop through the keys and if samplesSheet is given
// change the keys accordingly
string{} getReNamedMap(string{} fqMap, string samplesSheet) {
    string{} reNamedMap
    for(string fqKey : fqMap.keys()) {
    	string newKey = getSampleName(fqKey, samplesSheet)
        reNamedMap{newKey} = fqMap{fqKey}
    }
    return reNamedMap
}
// This function return hash with key set to root name 
// and value is the list of all associated FASTQ files
// that are spread across multiple lane during sequencing
string{} getFqMap(string[] fqFiles, string fqRegex, string extn) {
    # Map with unique root key
    string{} fqMap
    # loop over FASTQ files
    for(string fq : fqFiles) {
        int getR1Index = fq.lastIndexOf("_R1")
        int getR2Index = fq.lastIndexOf("_R2")

        if(getR1Index != -1) {
            # get the root of the file name with regex
            string[] getFile = fq.split(fqRegex)
            string rootName = getFile[0].baseName()
            # append to the list if it isn't in the list already
            if(!fqMap.hasKey(rootName)) fqMap{rootName}=""
            fqMap{rootName}+=fq+","
        }
        # Sometime data doesn't have neither R1 nor R2 in the file name
        # this block will insure that RNAsik-pipe still works correctly
        if((getR1Index == -1) && (getR2Index == -1)) {
		fqRegex = extn
                string[] getFile = fq.split(fqRegex)
                string rootName = getFile[0].baseName()
                # append to the list if it isn't in the list already
                if(!fqMap.hasKey(rootName)) fqMap{rootName}=""
                fqMap{rootName}+=fq+","
        }
    }
    return fqMap
}

string[] getFqReadsStats(string fqDir, string extn) {
    string[] allFastqFiles = getAllFastqFiles(fqDir, extn)
                                                   
    int numberOfMates = 0
    int numberOfSingles = 0
    int totalNumberOfReads = 0
    
    bool readPaired
    
    for(string fq : allFastqFiles){
        totalNumberOfReads += 1
        int getR1Index = fq.lastIndexOf("_R1")
        int getR2Index = fq.lastIndexOf("_R2")

        if(getR1Index != -1) {
            string pairedEnd = fq.replace("_R1", "_R2")
            bool checkPair = pairedEnd.exists()
            if(checkPair) {
                numberOfMates += 1
                numberOfSingles += 1
            }
            else numberOfSingles += 1
    
        }
        if( (getR1Index == -1) && (getR2Index == -1) ) {
            int allFastqFilesSize = allFastqFiles.size()
            totalNumberOfReads = allFastqFilesSize
            numberOfSingles = allFastqFilesSize
            string stat = "Total number of reads: "+totalNumberOfReads+"\nNumber of single end reads: "+numberOfSingles+"\nNumber of paired end pairs: "+numberOfMates
            readPaired = false
            return [stat, readPaired]
        }
    }

    if( (numberOfMates < numberOfSingles) && (numberOfMates != 0) ) error "It appears that the number of mates doesn't match"
    if(numberOfMates == 0) readPaired = false
    if(numberOfMates == numberOfSingles) readPaired = true

    string stat = "Total number of reads: "+totalNumberOfReads+"\nNumber of single end reads: "+numberOfSingles+"\nNumber of paired end pairs: "+numberOfMates
    return [stat, readPaired]
}
