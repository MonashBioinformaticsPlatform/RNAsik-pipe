#-----------------------------------------
# Fucntion to make indices for RNAsik-pipe
#-----------------------------------------

#------------------------------
# Make directories as required
#------------------------------

#------
# Body
#------
//string makeLocalFastaRef(string fastaRef) { 
//    // at this stage its unknown if Fasta is zipped or not
//    string localRef
//    // temp fix, look like a bug, if fastaRef is empty, fastaRef.baseName() returns working directory
//    if(!fastaRef.isEmpty()) localRef = refFiles+"/"+fastaRef.baseName()
//    string localFastaRef = localRef.removeExt(".gz")
//    dep(!fastaRef.isEmpty(), localRef <- fastaRef, taskName := "Copying FASTA file") sys cp -v $fastaRef $refFiles
//    dep(localRef.extName() == "gz", localFastaRef <- localRef, taskName := "gzip FASTA file") sys gunzip -c $localRef > $localFastaRef
//    goal localFastaRef
//    return localFastaRef
//}
//string makeLocalGTF(string gtfFile) {
//    // at this stage its unknown if GTF is zipped or not
//    string localRef = refFiles+"/"+gtfFile.baseName()
//    string localGTF = localRef.removeExt(".gz")
//    dep(!gtfFile.isEmpty(), localRef <- gtfFile, taskName := "Copying GTF file") sys cp -v $gtfFile $refFiles
//    dep(localGTF.extName() == "gz", localGTF <- localRef, taskName := "gunzip ing GTF file") sys gunzip -c $localRef > $localGTF
//    goal localGTF
//    return localGTF
//}

string makeLocalFastaRef(string fastaRef, string refFiles) { 
    if(fastaRef.extName() == "gz") error "Unzip your $fastaRef file before giving to the pipeline, with `gunzip` command" 
    string localFastaRef
    // temp fix, look like a bug, if fastaRef is empty, fastaRef.baseName() returns working directory
    if(!fastaRef.isEmpty()) localFastaRef = refFiles+"/"+fastaRef.baseName()
    //string localFastaRef = refFiles+"/"+fastaRef.baseName()
    task(!fastaRef.isEmpty(), localFastaRef <- fastaRef, taskName := "Copying FASTA file") sys cp -v $fastaRef $refFiles
    return localFastaRef
}

string makeLocalGTF(string gtfFile, string refFiles) {
    if(gtfFile.extName() == "gz") error "Unzip your $gtfFile file before giving to the pipeline, with `gunzip` command" 
    string localGTF
    // temp fix, look like a bug, if fastaRef is empty, fastaRef.baseName() returns working directory
    if(!gtfFile.isEmpty()) localGTF = refFiles+"/"+gtfFile.baseName()
    task(!gtfFile.isEmpty(), localGTF <- gtfFile, taskName := "Copying GTF file") sys cp -v $gtfFile $refFiles
    return localGTF
}

string makeSTARindex(string{} cmdExe, string refFiles, string fastaRef, string gtfFile, string starOpts, int threads) {
    // get STAR executable 
    if(!cmdExe.hasKey("starExe")) error "Can't get STAR executable, check your config file $configFile"
    string starExe = cmdExe{"starExe"}

    string genomeIdxDir = fastaRef.removeExt()+"-starIndex"
    if(!genomeIdxDir.exists()) genomeIdxDir.mkdir()

    string[] refFilesIn 
    refFilesIn += fastaRef

    int chkGTF = starOpts.indexOf("--sjdbGTFfile")
    if(chkGTF != -1) refFilesIn += gtfFile

    //task(genomeIdxDir <- refFilesIn, cpus := threads, taskName := "Making STAR index") {
    task(genomeIdxDir <- fastaRef, cpus := threads, taskName := "Making STAR index") {
        sys $starExe --runThreadN $threads \
                     --runMode genomeGenerate \
                     --outFileNamePrefix "$refFiles/" \
                     --genomeDir $genomeIdxDir \
                     --genomeFastaFiles $fastaRef \
                     $starOpts
    }
    return genomeIdxDir
}
// make dictionary for picard pre-processing
string makeDictFile(string{} cmdExe, string fastaRef) {
    if(!cmdExe.hasKey("picardExe")) error "Can't get picard executable, check your config file $configFile"
    string picardExe = cmdExe{"picardExe"}
    // make .dict string
    string fastaDictFile = fastaRef.removeExt()+".dict"
    //task(prePro, fastaDictFile <- fastaRef, taskName := "Making dictionary File") {
    task(prePro, fastaDictFile <- fastaRef, taskName := "Making dictionary File") {
        sys $picardExe CreateSequenceDictionary REFERENCE=$fastaRef \
                                                OUTPUT=$fastaDictFile
    }
    return fastaDictFile
}
// Index FASTA reference file when needed
string makeFaiFile(string samtoolsExe, string fastaRef) {
    // make a .fai string
    string fastaFaiFile = fastaRef+".fai"
    task(fastaFaiFile <- fastaRef, taskName := "Indexing FASTA file") {
        sys $samtoolsExe faidx $fastaRef
    }
    return fastaFaiFile
}
