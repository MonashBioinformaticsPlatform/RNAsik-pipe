/*
Abstracting away references
*/

include "sikRefUtils.bds"
include "sikUtils.bds"
include "sikSTARclass.bds"
include "sikBWAclass.bds"
include "sikConfigClass.bds"

 /*
 NOTE

 I think I need to stop coping reference files into sikRun directory, while it feels nice to have everything self contained
 I think there is a better way. If I'm going ahead with sik.config idea, where user specified everything in the single - main config
 than there is no need to copy reference file, which I mainly did for loggin purpose, the main config inplicitelly tracks which reference files
 were used.

I remembered, the reason I was copying reference fasta and annotation files into refFiles is because often I need to make fai and dict files as well as chromSizes
and depending on the tool, some require that those file located right next it's parent i.e fasta and fasta.fai need to be in the same directory, but if I'm sourcing
fasta from elsewhere and there isn't fai next to it, I can't (shouldn't even if can) write to some unknown location in the filesystem. So I do have a good reason to copy refrence files.
The only exception if the user passing previous refFiles, in that case, all required files should be there

 */

class ReferenceFiles {

    string fasta
    string faIdx
    string faDict
    string chromSizes
    string geneModels // probably nice abstraction here, since I'll be able to set geneModels to whatever object I need
    string genomeIdx // here genomeIdx should be the string that aligner expects, for STAR this will be directory name, for bwa mem it'll be file basename
    string refDir

    void ReferenceFiles(string{} sikCmdFlags, SikReferencesConfig _sikRefConf) {
        // NOTE here we need to make a check for users refFiles, and if given parse it out and sanity check

        string{} sikRefConf = _sikRefConf.sikRefConf

        string refFilesFn = getVal(sikCmdFlags, "refFiles")
        string genomeIdx = getVal(sikCmdFlags, "genomeIdx")
        string fastaFn = sikCmdFlags{"fasta"}
        string geneModelsFn = sikCmdFlags{"geneModels"}
        string aligner = sikCmdFlags{"aligner"}
        string sikDir = sikCmdFlags{"outDir"}
        bool mdups = sikCmdFlags{"mdups"}

        if(refFilesFn != "NULL") {

            string[] allowedFasta = ["fa", \
                                     "fasta", \
                                     "fna"]

            string[] allowedGeneModels = ["gtf", \
                                          "gff", \
                                          "gff3", \
                                          "saf"]

            string[] allowedOtherRef = ["fai", \
                                        "dict", \
                                        "chromSizes"]

            string{} allowedIdx = {"star" => "starIdx", \
                                   "hisat2" => "hisat2Idx", \
                                   "bwaMem" => "bwaIdx"}

            string[] allowedRefExt

            allowedRefExt += allowedGeneModels
            allowedRefExt += allowedFasta
            allowedRefExt += allowedOtherRef
            allowedRefExt += allowedIdx.values()

            for(string refFile : refFilesFn.dirPath()) {

                if(refFile.endsWith('.siklog')) {
                    continue
                }

                string extn = refFile.extName()

                if(extn == "gz") {
                    extn = refFile.removeExt().extName()
                }

                if(!allowedRefExt.has(extn)) {
                    warning "\n\
                             \n\
                             SikWarn: Identified unknown reference file in the $refFilesFn directory. Skipping this file $refFile
                             \n"
                    continue
                }

                if(allowedFasta.has(extn)) {
                    this.fasta = refFile
                }

                if(allowedGeneModels.has(extn)) {
                    this.geneModels = refFile
                }

                if(allowedOtherRef.has(extn)) {

                    switch(extn) {
                        case "fai":
                            this.faIdx = refFile
                            break
                        case "dict":
                            this.faDict = refFile
                            break
                        case "chromSizes":
                            chromSizes = refFile
                            break
                    }

                }

                if(allowedIdx.hasValue(extn)) {
                    if(genomeIdx != "NULL") {
                        warning "\n\
                                 \n\
                                 SikWarn: User specified both refFiles and genomeIdx, only one is sufficient. RNAsik will proceed with this genomeIdx $refFile
                                 \n"
                    }
                    assert(allowedIdx{aligner} == extn)
                    this.genomeIdx = refFile
                }
            }

        } else {

            this.refDir = sikDir+"/refFiles"

            if(!this.refDir.exists()) {
                this.refDir.mkdir()
            }

            string localFa

            string extn = fastaFn.extName()
            if(extn == "gz") {
                localFa = unBgzip(sikRefConf, fastaFn, this.refDir)
            } else {
                localFa = getRef(sikRefConf, fastaFn, this.refDir)
            }
            this.fasta = bgzip(sikRefConf, localFa)

            if(aligner == "star") {
                /*
                DOCS: this seems stupid but STAR aligner can handle gzipped FASTA reference, has to unzipped
                */
                this.fasta = localFa
            }

            this.faIdx = mkFai(sikRefConf, this.fasta)
            this.faDict = mkDict(sikRefConf, this.fasta, mdups)
            this.chromSizes = mkChromSizes(this.fasta)

            //NOTE could have function to turn geneModles into the object I want,
            // thinking about all the fuckiery I had with gff, gtf and genebank parsing abstract away here
            this.geneModels = getRef(sikRefConf, geneModelsFn, this.refDir)
        }
    }
}

class References extends ReferenceFiles {

    string[] idxDeps

    void References(SikConfig sikConf, SikReferencesConfig sikRefConf) {

        ReferenceFiles(sikConf.sikCmdFlags, sikRefConf)

        string aligner = sikConf.sikCmdFlags{"aligner"}

        switch(aligner) {
            case 'star':
                //SikStarAlingerConfig sikStarAlignerConf = new SikStarAlignerConfig(sikConf.usrResConf, sikConf.usrToolsConf)
                SikStarIdxConfig sikStarIdxConf = new SikStarIdxConfig(sikConf.usrResConf, sikConf.usrToolsConf)
                StarIndex starIdx = new StarIndex(sikStarIdxConf, this.fasta, this.refDir, this.genomeIdx)
                this.genomeIdx = starIdx.genomeIdx
                this.idxDeps = starIdx.idxDeps
                break
            case 'hisat2':
                error("SikErr: Haven't been implemented yet")
                break
            case 'bwaMem':
                SikBWAidxConfig sikBWAidxConf = new SikBWAidxConfig(sikConf.usrResConf, sikConf.usrToolsConf)
                BWAindex bwaIdx = new BWAindex(sikBWAidxConf, this.fasta, this.refDir, this.genomeIdx)
                this.genomeIdx = bwaIdx.genomeIdx
                this.idxDeps = bwaIdx.idxDeps
                break
            default:
                error("SikErr: There needs to be an error here to make sure nothing else is passed through, other than allowed aligners")
        }
    }
}
