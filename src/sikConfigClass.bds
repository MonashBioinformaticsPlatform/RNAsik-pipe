/*
Abstracting away config files interface
*/

/*

DOCS:
This story goes like this. SikConfig is a class that grabs user's specified config via -sikConfig argument. In the future it'll be the only argument use will need to specify.
The class parses sik.config and segregates into appropriate bins e.g cmd options, or STAR aligner specific options etc.
The following classes all inheret SikConfig. The SikResoucesConfig (the naming is a little ambigiouse) parses out all internal/global RNAsik config files, all the defaults that RNAsik comes with,
giving preference to the users input arguments. I guess the future TODO is to somehow also validate SikConfig for intergraty. I'm doing that, but not as regious I think.
Finally each tool should have it's own class e.g StarConfig which holds all configurations need for STAR to run.
It appears to me that my previous class sikResoucesClass.bds has become redundant

*/

class SikConfig {
    //NOTE
    // This is it ! sik yeh!
    /*
       DOCS:
       This class takes sik.config with a bag of random keys, segregates them into appropriate areas and passes them on.
       All other classes extend this one
       The final class is Config(), that way in the code I simply call config := new Config() and "magically" I'll have everything I need right, right?
       This class has the following objects:

       - sikCmdFlgas
       - usrResConfg
       - usrStarConf
       - usrCntsConfg

       TODO each additional tool should have its own slot in this class e.g string{} usrFlagstatConf
    */

    string{} _unassigned   //note sure what to do with these yet, error out for now
    string{} sikCmdFlags   // user resources
    string{} usrResConf
    string{} usrStarConf
    string{} usrCntsConf

    void SikConfig(string sikConfigFn) {

        string configOriginFn = programPath.pathName()+"/../configs"
        string resourcesAllowedKeysFn = configOriginFn + "/sikAllowedKeys/resources.txt"
        assert(resourcesAllowedKeysFn.exists())
        string[] resourcesAllowedKeys = resourcesAllowedKeysFn.readLines()

        string starAllowedKeysFn = configOriginFn + "/sikAllowedKeys/star.txt"
        assert(starAllowedKeysFn.exists())
        string[] starAllowedKeys = starAllowedKeysFn.readLines()

        string featureCountsAllowedKeysFn = configOriginFn + "/sikAllowedKeys/featureCounts.txt"
        assert(featureCountsAllowedKeysFn.exists())
        string[] featureCountsAllowedKeys = featureCountsAllowedKeysFn.readLines()

        string[] sikCmdKeys = ["metadata", \
                               "aligner", \
                               "refFiles", \
                               "paired", \
                               "geneModels", \
                               "genomeIdx", \
                               "fasta", \
                               "counts", \
                               "mdups", \
                               "qc", \
                               "outDir"]

        assert(sikConfigFn.exists())
        string{} sikConfig = config(sikConfigFn)

        for(string k : sikConfig.keys()) {

            if(resourcesAllowedKeys.has(k)) {
                this.usrResConf{k} = sikConfig{k}
                continue
            } else if(starAllowedKeys.has(k)) {
                this.usrStarConf{k} = sikConfig{k}
                continue
            } else if(featureCountsAllowedKeys.has(k)) {
                this.usrCntsConf{k} = sikConfig{k}
                continue
            } else if(sikCmdKeys.has(k)) {
                this.sikCmdFlags{k} = sikConfig{k}
                continue
            } else {
                this._unassigned{k} = sikConfig{k}
            }
        }

        if(_unassigned.size() > 0) {
            error "\n\
                   \n\
                   SikErr: Too many _unassigned keys in the config file\
                   \n\
                   $_unassigned\
                   \n"
        }
    }
}

class SikResourcesConfig {

    string{} _sikResConf

    void SikResourcesConfig(string{} usrResConf) {

        string configOriginFn = programPath.pathName()+"/../configs"
        string sikRefConfFn = configOriginFn + "/sikResources.config"
        assert(sikRefConfFn.exists())

        this._sikResConf = config(sikRefConfFn)

        for(string k : this._sikResConf.keys()) {
            if(usrResConf.hasKey(k)) {
                _sikResConf{k} = usrResConf{k}
            }
        }
    }
}

// NOTE This class is the one I want to pass around. It should have all necessary parameters for the tool execution
// In general it now becomes relativelly easy to extend RNAsik with new aligner, simply add a class for your aligner of choice
// in this case STAR
// Class methods:
// - toolExe
// - alignerCpu
// - alignerMem
// - mkIdxCpu
// - mkIdxMem
// - toolArgs

class SikStarConfig extends SikResourcesConfig {

/*

DOCS: This class takes, takes global sikRefConf that holds information about all required resources and usrStarConf information which is anything that
user specified and adjusted for STAR to work with. The SikStarConfig can then be passed to STAR indexing and alignment. Main objects from this class are:

- alignerRes
- alignerCmdOpts

AND

- idxRes
- idxCmdOpts

*/


/*
FYI:
The following keys are removed from allowed keys
--runMode: is special and set internally only
--runThread and --runThreadN: are resource keys, they set through different avenue via sik.config starAlingerCpu and starAlignerMem
--outFileNamePrefix: this is sample specific and is set via samples sheet
--genomeDir: this is set internally in RNAsik, no need to set it externally
--genomeFastaFiles: as per --genomeDir

*/

/*

NOTE
As far as index specific keys goes, I think there is only --genomeSAindexNbases and --genomeChrBinNbits
all other keys can be included either at the mapping or indexing step
I guess it would be important to know how the reference was made

I'm not sure what to do if I find --sjdbSTFfile key in the user (sik.config) config file, do I pass it at indexing step
or do I pass to mapping step? I guess doing at index step would mean that it happened once, whereas if I'm passing it at
the alignment step I would have to pass it every time, N samples.

I guess for now I'll will only pass those to indexing, ah.. actually if the index directory and already exists and/or user passing it in directly
then I should pass those to the alignment step

This config class needs to know whether user has passed in refFiles with pre-existing indecies

*/
    string{} alignerRes
    string[] alignerCmdOpts

    string{} idxRes
    string[] idxCmdOpts

    string{} _sikStarConf // private to this class

    void SikStarConfig(string{} usrResConf, string{} usrStarConf) {

        SikResourcesConfig(usrResConf)

        string[] idxKeys = ["--sjdbGTFfile", \
                            "--sjdbOverhang", \
                            "--sjdbGTFtagExonParentTranscript", \
                            "--sjdbGTFfeatureExon", \
                            "--sjdbGTFtagExonParentTranscript", \
                            "--sjdbFileChrStartEnd", \
                            "--genomeSAindexNbases", \
                            "--genomeChrBinNbits"]

        string configOriginFn = programPath.pathName()+"/../configs"
        string sikStarConfigFn = configOriginFn + "/sikCmdOptions/star.config"
        assert(sikStarConfigFn.exists())

        this._sikStarConf = config(sikStarConfigFn)

        string[] keys = this._sikStarConf.keys()
        keys += usrStarConf.keys()
        keys = unique(keys)

        for(string k : keys) {

            if(usrStarConf.hasKey(k)) {
                /*
                  TODO this is hasn't been properly implemented. At this stage I'm simply assuming that the user can't pass
                */
                if(idxKeys.has(k)) {
                    idxCmdOpts.add([k, usrStarConf{k}].join(" "))
                } else {
                    alignerCmdOpts.add([k, usrStarConf{k}].join(" "))
                }

            } else {
                alignerCmdOpts.add([k, this._sikStarConf{k}].join(" "))
            }
        }

        //TODO sanity check for all keys are found in the
        string[] sanityChk = ["starAlignerCpu", \
                              "starAlignerMem", \
                              "starIdxCpu", \
                              "starIdxMem", \
                              "starExe"]

        for(string k : sanityChk) {
            if(!this._sikResConf.hasKey(k)) {
                error "\n\
                       \n\
                       SikErr: Key not found -> $k. Check you configuration files \
                       \n"
            }
        }

        alignerRes{"alignerCpu"} = this._sikResConf{"starAlignerCpu"}
        alignerRes{"alignerMem"} = this._sikResConf{"starAlignerMem"}
        alignerRes{"starExe"} = this._sikResConf{"starExe"}

        idxRes{"idxCpu"} = this._sikResConf{"starIdxCpu"}
        idxRes{"idxMem"} = this._sikResConf{"starIdxMem"}
        idxRes{"starExe"} = this._sikResConf{"starExe"}

    }
}

class SikReferencesConfig extends SikResourcesConfig {

    string{} sikRefConf
    //NOTE I can later extend this class to also allow custome cmd options passing
    // will leave it as is for now, since I haven't seen a lot of use case for this
    //string[] refCmdOpts
    void SikReferencesConfig(string{} usrResConf) {

        SikResourcesConfig(usrResConf)

        sikRefConf{"cpExe"} = this._sikResConf{"cpExe"}
        sikRefConf{"cpCpu"} = this._sikResConf{"cpCpu"}
        sikRefConf{"cpMem"} = this._sikResConf{"cpMem"}

        sikRefConf{"bgzipExe"} = this._sikResConf{"bgzipExe"}
        sikRefConf{"bgzipCpu"} = this._sikResConf{"bgzipCpu"}
        sikRefConf{"bgzipMem"} = this._sikResConf{"bgzipMem"}

        sikRefConf{"faiExe"} = this._sikResConf{"samtoolsExe"} + " faidx"
        sikRefConf{"faiCpu"} = this._sikResConf{"samtoolsFaidxCpu"}
        sikRefConf{"faiMem"} = this._sikResConf{"samtoolsFaidxMem"}

        sikRefConf{"dictExe"} = this._sikResConf{"picardExe"} + " CreateSequenceDictionary"
        sikRefConf{"dictCpu"} = this._sikResConf{"picardDictCpu"}
        sikRefConf{"dictMem"} = this._sikResConf{"picardDictMem"}
    }
}
