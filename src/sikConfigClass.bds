/*
Abstracting away config files interface
*/

/*

DOCS:
This story goes like this. SikConfig is a class that grabs user's specified config via -sikConfig argument. In the future it'll be the only argument use will need to specify.
The class parses sik.config and segregates into appropriate bins e.g cmd options, or STAR aligner specific options etc.
The following classes all inheret SikConfig. The SikResoucesConfig (the naming is a little ambigiouse) parses out all internal/global RNAsik config files, all the defaults that RNAsik comes with,
giving preference to the users input arguments. I guess the future TODO is to somehow also validate SikConfig for intergraty. I'm doing that, but not as regious I think.
Finally each tool should have it's own class e.g StarConfig which holds all configurations need for STAR to run.
It appears to me that my previous class sikResoucesClass.bds has become redundant

*/

class SikConfig {
    //NOTE
    // This is it ! sik yeh!
    /*
       DOCS:
       This class takes sik.config with a bag of random keys, segregates them into appropriate areas and passes them on.
       All other classes extend this one
       The final class is Config(), that way in the code I simply call config := new Config() and "magically" I'll have everything I need right, right?
       This class has the following objects:

       - sikCmdFlgas
       - usrResConfg
       - usrStarConf
       - usrCntsConfg

       TODO each additional tool should have its own slot in this class e.g string{} usrFlagstatConf
    */

    string _configOriginFn = programPath.pathName()+"/../configs"

    string{} _unassigned   //note sure what to do with these yet, error out for now

    string{} sikCmdFlags
    string{} usrResConf
    string{} usrToolsConf

    void SikConfig(string sikConfigFn) {


        /*
            DOCS: User specified sikConfig can hold keys from:

                - sikCmdOpts.txt   keys to pass certain values to RNAsik
                - tools.txt        additional keys to custom configure individual tools
                - resources.txt    custom resources requirements by user
        */

        string sikCmdKeysFn = this._configOriginFn + "/sikAllowedKeys/sikCmdOpts.txt"
        assert(sikCmdKeysFn.exists())
        string[] sikCmdKeys = sikCmdKeysFn.readLines()

        string toolsAllowedKeysFn = this._configOriginFn + "/sikAllowedKeys/tools.txt"
        assert(toolsAllowedKeysFn.exists())
        string[] toolsAllowedKeys = toolsAllowedKeysFn.readLines()

        string resourcesAllowedKeysFn = this._configOriginFn + "/sikAllowedKeys/resources.txt"
        assert(resourcesAllowedKeysFn.exists())
        string[] resourcesAllowedKeys = resourcesAllowedKeysFn.readLines()

        assert(sikConfigFn.exists())
        string{} sikConfig = config(sikConfigFn)

        for(string k : sikConfig.keys()) {

            if(resourcesAllowedKeys.has(k)) {
                this.usrResConf{k} = sikConfig{k}
            } else if(toolsAllowedKeys.has(k)) {
                this.usrToolsConf{k} = sikConfig{k}
            } else if(sikCmdKeys.has(k)) {
                this.sikCmdFlags{k} = sikConfig{k}
            } else {
                this._unassigned{k} = sikConfig{k}
            }
        }

        if(this._unassigned.size() > 0) {
            error "\n\
                   \n\
                   SikErr: Too many _unassigned keys in the config file\
                   \n\
                   $this._unassigned\
                   \n"
        }
    }
}

class SikResourcesConfig {

    string{} _sikResConf
    string _configOriginFn = programPath.pathName()+"/../configs"

    void SikResourcesConfig(string{} usrResConf) {

        string sikRefConfFn = this._configOriginFn + "/sikResources.config"
        assert(sikRefConfFn.exists())

        this._sikResConf = config(sikRefConfFn)

        for(string k : this._sikResConf.keys()) {
            if(usrResConf.hasKey(k)) {
                _sikResConf{k} = usrResConf{k}
            }
        }
    }
}

// NOTE This class is the one I want to pass around. It should have all necessary parameters for the tool execution
// In general it now becomes relativelly easy to extend RNAsik with new aligner, simply add a class for your aligner of choice
// in this case STAR
// Class methods:
// - toolExe
// - alignerCpu
// - alignerMem
// - mkIdxCpu
// - mkIdxMem
// - toolArgs

class SikStarIdxConfig extends SikResourcesConfig {

    string{} idxRes
    string[] idxCmdOpts

    string{} _sikStarIdxConf // private to this class

    void SikStarIdxConfig(string{} usrResConf, string{} usrToolsConf) {

        SikResourcesConfig(usrResConf)

        string{} usrStarIdxOpts

        if(usrToolsConf.hasKey("starIdx")) {
            usrStarIdxOpts = parseUsrToolsOpts("starIdx", usrToolsConf{"starIdx"})
        }

        string sikStarIdxConfigFn = this._configOriginFn + "/sikCmdOptions/starIdx.config"
        assert(sikStarIdxConfigFn.exists())
        this._sikStarIdxConf = config(sikStarIdxConfigFn)

        string[] keys = this._sikStarIdxConf.keys()
        keys += usrStarIdxOpts.keys()
        keys = unique(keys)

        for(string k : keys) {
            if(usrStarIdxOpts.hasKey(k)) {
                idxCmdOpts.add([k, usrStarIdxOpts{k}].join(" "))
            } else {
                idxCmdOpts.add([k, this._sikStarIdxConf{k}].join(" "))
            }
        }

        string[] sanityChk = ["starIdxCpu", \
                              "starIdxMem", \
                              "starExe"]

        for(string k : sanityChk) {
            if(!this._sikResConf.hasKey(k)) {
                error "\n\
                       \n\
                       SikErr: Key not found -> $k. Check you configuration files \
                       \n"
            }
        }

        idxRes{"idxCpu"} = this._sikResConf{"starIdxCpu"}
        idxRes{"idxMem"} = this._sikResConf{"starIdxMem"}
        idxRes{"starExe"} = this._sikResConf{"starExe"}

    }
}

class SikStarAlignerConfig extends SikResourcesConfig {
/*

DOCS: This class takes, takes global sikRefConf that holds information about all required resources and usrStarConf information which is anything that
user specified and adjusted for STAR to work with. The SikStarConfig can then be passed to STAR indexing and alignment. Main objects from this class are:

- alignerRes
- alignerCmdOpts

AND

- idxRes
- idxCmdOpts

FYI:
The following keys are removed from allowed keys

--runMode: is special and set internally only
--runThread and --runThreadN: are resource keys, they set through different avenue via sik.config starAlingerCpu and starAlignerMem
--outFileNamePrefix: this is sample specific and is set via samples sheet
--genomeDir: this is set internally in RNAsik, no need to set it externally
--genomeFastaFiles: as per --genomeDir

NOTE
As far as index specific keys goes, I think there is only --genomeSAindexNbases and --genomeChrBinNbits
all other keys can be included either at the mapping or indexing step. I guess it would be important to know how the reference was made
*/
    string{} alignerRes
    string[] alignerCmdOpts

    string{} _sikStarAlignerConf // private to this class

    void SikStarAlignerConfig(string{} usrResConf, string{} usrToolsConf) {

        SikResourcesConfig(usrResConf)

        string{} usrStarAlignerOpts

        if(usrToolsConf.hasKey("starAligner")) {
            usrStarAlignerOpts = parseUsrToolsOpts("starAligner", usrToolsConf{"starAligner"})
        }

        string sikStarAlignerConfigFn = this._configOriginFn + "/sikCmdOptions/starAligner.config"
        assert(sikStarAlignerConfigFn.exists())
        this._sikStarAlignerConf = config(sikStarAlignerConfigFn)

        string[] keys = this._sikStarAlignerConf.keys()
        keys += usrStarAlignerOpts.keys()
        keys = unique(keys)

        for(string k : keys) {

            //TODO should check for aberant characters in the opts string e.g : or - or _ or ,
            // something that user might have passed in accidently that causes downstream error
            if(usrStarAlignerOpts.hasKey(k)) {
                alignerCmdOpts.add([k, usrStarAlignerOpts{k}].join(" "))
            } else {
                alignerCmdOpts.add([k, this._sikStarAlignerConf{k}].join(" "))
            }
        }

        string[] sanityChk = ["starAlignerCpu", \
                              "starAlignerMem", \
                              "starExe"]

        for(string k : sanityChk) {
            if(!this._sikResConf.hasKey(k)) {
                error "\n\
                       \n\
                       SikErr: Key not found -> $k. Check you configuration files \
                       \n"
            }
        }

        alignerRes{"alignerCpu"} = this._sikResConf{"starAlignerCpu"}
        alignerRes{"alignerMem"} = this._sikResConf{"starAlignerMem"}
        alignerRes{"starExe"} = this._sikResConf{"starExe"}
    }
}

class SikReferencesConfig extends SikResourcesConfig {

    string{} sikRefConf
    //NOTE I can later extend this class to also allow custome cmd options passing
    // will leave it as is for now, since I haven't seen a lot of use case for this
    //string[] refCmdOpts
    void SikReferencesConfig(string{} usrResConf) {

        SikResourcesConfig(usrResConf)

        sikRefConf{"cpExe"} = this._sikResConf{"cpExe"}
        sikRefConf{"cpCpu"} = this._sikResConf{"cpCpu"}
        sikRefConf{"cpMem"} = this._sikResConf{"cpMem"}

        sikRefConf{"bgzipExe"} = this._sikResConf{"bgzipExe"}
        sikRefConf{"bgzipCpu"} = this._sikResConf{"bgzipCpu"}
        sikRefConf{"bgzipMem"} = this._sikResConf{"bgzipMem"}

        sikRefConf{"faiExe"} = this._sikResConf{"samtoolsExe"} + " faidx"
        sikRefConf{"faiCpu"} = this._sikResConf{"samtoolsFaidxCpu"}
        sikRefConf{"faiMem"} = this._sikResConf{"samtoolsFaidxMem"}

        sikRefConf{"dictExe"} = this._sikResConf{"picardExe"} + " CreateSequenceDictionary"
        sikRefConf{"dictCpu"} = this._sikResConf{"picardDictCpu"}
        sikRefConf{"dictMem"} = this._sikResConf{"picardDictMem"}
    }
}
