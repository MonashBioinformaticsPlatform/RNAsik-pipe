/*
Abstracting away config files interface
*/

/*

DOCS:
This story goes like this. SikConfig is a class that grabs user's specified config via -sikConfig argument. In the future it'll be the only argument use will need to specify.
The class parses sik.config and segregates into appropriate bins e.g cmd options, or STAR aligner specific options etc.
The following classes all inheret SikConfig. The SikResoucesConfig (the naming is a little ambigiouse) parses out all internal/global RNAsik config files, all the defaults that RNAsik comes with,
giving preference to the users input arguments. I guess the future TODO is to somehow also validate SikConfig for intergraty. I'm doing that, but not as regious I think.
Finally each tool should have it's own class e.g StarConfig which holds all configurations need for STAR to run.
It appears to me that my previous class sikResoucesClass.bds has become redundant

*/

class SikConfig {
    //NOTE
    // This is it ! sik yeh!
    // DOCS:
    // This class takes sik.config with a bag of random keys, segregates them into appropriate areas and passes them on.
    // All other classes extend this one
    // The final class is Config(), that way in the code I simply call config := new Config() and "magically" I'll have everything I need right, right?

    string configOriginFn = programPath.pathName()+"/../configs"

    // General configs
    string{} resourcesConfig

    // Problematic key=values
    string{} unassigned

    // tooling config
    string{} starConfig
    string{} featureCountsConfig
    string{} sikCmdFlags

    //TODO
    //string{} samtoolsFlagstatConfig
    //string{} samtoolsStatConfig

    void SikConfig(string sikConfigFn) {

        string resourcesAllowedKeysFn = this.configOriginFn + "/sikAllowedKeys/resources.txt"
        assert(resourcesAllowedKeysFn.exists())
        string[] resourcesAllowedKeys = resourcesAllowedKeysFn.readLines()

        string starAllowedKeysFn = this.configOriginFn + "/sikAllowedKeys/star.txt"
        assert(starAllowedKeysFn.exists())
        string[] starAllowedKeys = starAllowedKeysFn.readLines()

        string featureCountsAllowedKeysFn = this.configOriginFn + "/sikAllowedKeys/featureCounts.txt"
        assert(featureCountsAllowedKeysFn.exists())
        string[] featureCountsAllowedKeys = featureCountsAllowedKeysFn.readLines()

        string[] sikCmdKeys = ["sikConfig", \
                               "metadata", \
                               "aligner", \
                               "refFiles", \
                               "paired", \
                               "geneModels", \
                               "fasta", \
                               "counts", \
                               "mdups", \
                               "qc", \
                               "outDir"]

        assert(sikConfigFn.exists())
        string{} sikConfig = config(sikConfigFn)

        for(string k : sikConfig.keys()) {

            if(resourcesAllowedKeys.has(k)) {
                this.resourcesConfig{k} = sikConfig{k}
                continue
            } else if(starAllowedKeys.has(k)) {
                this.starConfig{k} = sikConfig{k}
                continue
            } else if(featureCountsAllowedKeys.has(k)) {
                this.featureCountsConfig{k} = sikConfig{k}
                continue
            } else if(sikCmdKeys.has(k)) {
                this.sikCmdFlags{k} = sikConfig{k}
                continue
            } else {
                this.unassigned{k} = sikConfig{k}
            }
        }

        if(unassigned.size() > 0) {
            error "\n\
                   \n\
                   SikErr: Too many unassigned keys in the config file\
                   \n\
                   $unassigned\
                   \n"
        }
    }
}

class SikResourcesConfig extends SikConfig {

    string{} sikResourcesConfig

    void SikResourcesConfig(string sikConfigFn) {

        SikConfig(sikConfigFn)

        string sikResourcesConfigFn = this.configOriginFn + "/sikResources.config"
        assert(sikResourcesConfigFn.exists())

        this.sikResourcesConfig = config(sikResourcesConfigFn)

        for(string k : this.sikResourcesConfig.keys()) {
            if(this.resourcesConfig.hasKey(k)) {
                sikResourcesConfig{k} = this.resourcesConfig{k}
            }
        }
    }
}

// NOTE This class is the one I want to pass around. It should have all necessary parameters for the tool execution
// In general it now becomes relativelly easy to extend RNAsik with new aligner, simply add a class for your aligner of choice
// in this case STAR
// Class methods:
// - toolExe
// - alignerCpu
// - alignerMem
// - mkIdxCpu
// - mkIdxMem
// - toolArgs

class StarConfig extends SikResourcesConfig {

/*
FYI:
The following keys are removed from allowed keys
--runMode: is special and set internally only
--runThread and --runThreadN: are resource keys, they set through different avenue via sik.config starAlingerCpu and starAlignerMem
--outFileNamePrefix: this is sample specific and is set via samples sheet
--genomeDir: this is set internally in RNAsik, no need to set it externally
--genomeFastaFiles: as per --genomeDir

*/

/*

NOTE
As far as index specific keys goes, I think there is only --genomeSAindexNbases and --genomeChrBinNbits
all other keys can be included either at the mapping or indexing step
I guess it would be important to know how the reference was made

I'm not sure what to do if I find --sjdbSTFfile key in the user (sik.config) config file, do I pass it at indexing step
or do I pass to mapping step? I guess doing at index step would mean that it happened once, whereas if I'm passing it at
the alignment step I would have to pass it every time, N samples.

I guess for now I'll will only pass those to indexing, ah.. actually if the index directory and already exists and/or user passing it in directly
then I should pass those to the alignment step

This config class needs to know whether user has passed in refFiles with pre-existing indecies

*/
    string{} alignerResources
    string[] alignerCmdOpts
    string[] indexCmdOpts
    // TODO I need to figure out how make sikStarConfig internal use only. I don't really need this to be exposed to the outside
    // I think convention is to use underscore prefix i.e _sikStarConfig
    string{} _sikStarConfig

    void StarConfig(string sikConfigFn, bool paired) {

        SikResourcesConfig(sikConfigFn)

        string[] idxKeys = ["--sjdbGTFfile", \
                            "--sjdbOverhang", \
                            "--sjdbGTFtagExonParentTranscript", \
                            "--sjdbGTFfeatureExon", \
                            "--sjdbGTFtagExonParentTranscript", \
                            "--sjdbFileChrStartEnd", \
                            "--genomeSAindexNbases", \
                            "--genomeChrBinNbits"]

        string sikStarConfigFn = this.configOriginFn + "/sikCmdOptions/star.config"
        assert(sikStarConfigFn.exists())

        // TODO need to set / check paired end flags?

        this._sikStarConfig = config(sikStarConfigFn)

        for(string k : this._sikStarConfig.keys()) {

            if(this.starConfig.hasKey(k)) {
                /*
                  TODO this is hasn't been properly implemented. At this stage I'm simply assuming that the user can't pass
                */
                if(idxKeys.has(k)) {
                    indexCmdOpts.add([k, this.starConfig{k}].join(" "))
                } else {
                    alignerCmdOpts.add([k, this.starConfig{k}].join(" "))
                }

            } else {
                alignerCmdOpts.add([k, this._sikStarConfig{k}].join(" "))
            }
        }

        //TODO sanity check for all keys are found in the
        string[] sanityChk = ["starAlignerCpu", \
                              "starAlignerMem", \
                              "starIdxCpu", \
                              "starIdxMem", \
                              "starExe"]

        for(string k : sanityChk) {
            if(!this.sikResourcesConfig.hasKey(k)) {
                error "\n\
                       \n\
                       SikErr: Key not found -> $k. Check you configuration files \
                       \n"
            }
        }

        alignerResources{"alignerCpu"} = this.sikResourcesConfig{"starAlignerCpu"}
        alignerResources{"alignerMem"} = this.sikResourcesConfig{"starAlignerMem"}
        alignerResources{"idxCpu"} = this.sikResourcesConfig{"starIdxCpu"}
        alignerResources{"idxMem"} = this.sikResourcesConfig{"starIdxMem"}
        alignerResources{"starExe"} = this.sikResourcesConfig{"starExe"}

    }
}

class RefConfig extends SikResourcesConfig {

    string{} refResouces
    //NOTE I can later extend this class to also allow custome cmd options passing
    // will leave it as is for now, since I haven't seen a lot of use case for this
    //string[] refCmdOpts
    void RefConfig(string sikConfigFn) {

        SikResourcesConfig(sikConfigFn)

        refResouces{"cpExe"} = this.sikResourcesConfig{"cpExe"}
        refResouces{"cpCpu"} = this.sikResourcesConfig{"cpCpu"}
        refResouces{"cpMem"} = this.sikResourcesConfig{"cpMem"}

        refResouces{"faiExe"} = this.sikResourcesConfig{"samtoolsExe"} + " faidx"
        refResouces{"faiCpu"} = this.sikResourcesConfig{"samtoolsFaidxCpu"}
        refResouces{"faiMem"} = this.sikResourcesConfig{"samtoolsFaidxMem"}

        refResouces{"dictExe"} = this.sikResourcesConfig{"picardExe"} + " CreateSequenceDictionary"
        refResouces{"dictCpu"} = this.sikResourcesConfig{"picardDictCpu"}
        refResouces{"dictMem"} = this.sikResourcesConfig{"picardDictMem"}

    }

}
//class CountsConfig extends SikConfig {
//
//    string{} sikCountsConfig
//
//    void CountsConfig(string sikConfigFn, bool paired) {
//
//        SikConfig(sikConfigFn)
//
//        string sikCountsConfigFn = this.configOriginFn + "/sikCmdOptions/featureCounts.config"
//        assert(sikCountsConfigFn.exists())
//
//        // TODO need to set / check paired end flags
//
//        this.sikCountsConfig = config(sikCountsConfigFn)
//
//        for(string k : this.sikCountsConfig.keys()) {
//            if(this.featureCountsConfig.hasKey(k)) {
//                sikCountsConfig{k} = this.featureCountsConfig{k}
//            }
//        }
//    }
//}
