/*
Abstracting away config files interface
*/

include "sikSTARclass.bds"
include "sikBWAclass.bds"
include "sikSamtoolsClass.bds"

/*

DOCS:
This story goes like this. SikConfig is a class that grabs user's specified config via -sikConfig argument. In the future it'll be the only argument use will need to specify.
The class parses sik.config and segregates into appropriate bins e.g cmd options, or STAR aligner specific options etc.
The following classes all inheret SikConfig. The SikResoucesConfig (the naming is a little ambigiouse) parses out all internal/global RNAsik config files, all the defaults that RNAsik comes with,
giving preference to the users input arguments. I guess the future TODO is to somehow also validate SikConfig for intergraty. I'm doing that, but not as regious I think.
Finally each tool should have it's own class e.g StarConfig which holds all configurations need for STAR to run.
It appears to me that my previous class sikResoucesClass.bds has become redundant

*/

class SikConfig {
    //NOTE
    // This is it ! sik yeh!
    /*
       DOCS:
       This class takes sik.config with a bag of random keys, segregates them into appropriate areas and passes them on.
       All other classes extend this one
       The final class is Config(), that way in the code I simply call config := new Config() and "magically" I'll have everything I need right, right?
       This class has the following objects:

       - sikCmdFlgas
       - usrResConfg
       - usrStarConf
       - usrCntsConfg

       TODO each additional tool should have its own slot in this class e.g string{} usrFlagstatConf
    */

    string _configOriginFn = programPath.pathName()+"/../configs"

    string{} _unassigned   //note sure what to do with these yet, error out for now

    string{} sikCmdFlags
    string{} usrResConf
    string{} usrToolsConf

    void SikConfig(string sikConfigFn) {


        /*
            DOCS: User specified sikConfig can hold keys from:

                - sikCmdOpts.txt   keys to pass certain values to RNAsik
                - tools.txt        additional keys to custom configure individual tools
                - resources.txt    custom resources requirements by user
        */

        string sikCmdKeysFn = this._configOriginFn + "/sikAllowedKeys/sikCmdOpts.txt"
        assert(sikCmdKeysFn.exists())
        string[] sikCmdKeys = sikCmdKeysFn.readLines()

        string toolsAllowedKeysFn = this._configOriginFn + "/sikAllowedKeys/tools.txt"
        assert(toolsAllowedKeysFn.exists())
        string[] toolsAllowedKeys = toolsAllowedKeysFn.readLines()

        string resourcesAllowedKeysFn = this._configOriginFn + "/sikAllowedKeys/resources.txt"
        assert(resourcesAllowedKeysFn.exists())
        string[] resourcesAllowedKeys = resourcesAllowedKeysFn.readLines()

        assert(sikConfigFn.exists())
        string{} sikConfig = config(sikConfigFn)

        for(string k : sikConfig.keys()) {

            if(resourcesAllowedKeys.has(k)) {
                this.usrResConf{k} = sikConfig{k}
            } else if(toolsAllowedKeys.has(k)) {
                this.usrToolsConf{k} = sikConfig{k}
            } else if(sikCmdKeys.has(k)) {
                this.sikCmdFlags{k} = sikConfig{k}
            } else {
                this._unassigned{k} = sikConfig{k}
            }
        }

        if(this._unassigned.size() > 0) {
            error "\n\
                   \n\
                   SikErr: Too many _unassigned keys in the config file\
                   \n\
                   $this._unassigned\
                   \n"
        }
    }
}

class SikResourcesConfig {

    string{} _sikResConf
    string _configOriginFn = programPath.pathName()+"/../configs"

    void SikResourcesConfig(string{} usrResConf) {

        string sikRefConfFn = this._configOriginFn + "/sikResources.config"
        assert(sikRefConfFn.exists())

        this._sikResConf = config(sikRefConfFn)

        for(string k : this._sikResConf.keys()) {
            if(usrResConf.hasKey(k)) {
                _sikResConf{k} = usrResConf{k}
            }
        }
    }
}

class SikReferencesConfig extends SikResourcesConfig {

    string{} sikRefConf
    //NOTE I can later extend this class to also allow custome cmd options passing
    // will leave it as is for now, since I haven't seen a lot of use case for this
    //string[] refCmdOpts
    void SikReferencesConfig(string{} usrResConf) {

        SikResourcesConfig(usrResConf)

        sikRefConf{"cpExe"} = this._sikResConf{"cpExe"}
        sikRefConf{"cpCpu"} = this._sikResConf{"cpCpu"}
        sikRefConf{"cpMem"} = this._sikResConf{"cpMem"}

        sikRefConf{"bgzipExe"} = this._sikResConf{"bgzipExe"}
        sikRefConf{"bgzipCpu"} = this._sikResConf{"bgzipCpu"}
        sikRefConf{"bgzipMem"} = this._sikResConf{"bgzipMem"}

        sikRefConf{"faiExe"} = this._sikResConf{"samtoolsExe"} + " faidx"
        sikRefConf{"faiCpu"} = this._sikResConf{"samtoolsFaidxCpu"}
        sikRefConf{"faiMem"} = this._sikResConf{"samtoolsFaidxMem"}

        sikRefConf{"dictExe"} = this._sikResConf{"picardExe"} + " CreateSequenceDictionary"
        sikRefConf{"dictCpu"} = this._sikResConf{"picardDictCpu"}
        sikRefConf{"dictMem"} = this._sikResConf{"picardDictMem"}
    }
}

class AlignerConfig {

    SikBWAalignerConfig sikBWAalignerConf
    SikStarAlignerConfig sikStarAlignerConf

    void AlignerConfig(string{} usrResConf, string{} usrToolsConf, string aligner) {

        switch(aligner) {
            case 'star':
                sikStarAlignerConf = new SikStarAlignerConfig(usrResConf, usrToolsConf)
                break
            case 'hisat2':
                error("SikErr: Haven't been implemented yet")
                break
            case 'bwaMem':
                sikBWAalignerConf = new SikBWAalignerConfig(usrResConf, usrToolsConf)
                break
            default:
                error("SikErr: There needs to be an error here to make sure nothing else is passed through, other than allowed aligners")

        }
    }
}

class SortConfig {
    //TODO can have another class here with a switch to support different sorting tools e.g picard vs samtools, or could even have STAR, will leave it out for now
    SikSamtoolsSortConfig samtoolsSortConf
    //SikPicardSortConfig picardSortConf //TODO hasn't been implemented

    void SortConfig(string{} usrResConf, string{} usrToolsConf, string aligner) {

        string sortingTool = "samtools"

        switch(sortingTool) {
            case 'samtools':
                samtoolsSortConf = new SikSamtoolsSortConfig(usrResConf, usrToolsConf)
                break
            case 'picard':
                error("SikErr: Haven't been implemented yet")
                break
            default:
                error("SikErr: There needs to be an error here to make sure nothing else is passed through, other than allowed aligners")

        }
    }
}
